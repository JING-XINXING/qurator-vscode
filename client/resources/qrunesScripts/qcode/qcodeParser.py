# Generated from Qcode.g4 by ANTLR 4.7.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3n")
        buf.write("\u022a\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63\t\63\4\64\t\64")
        buf.write("\4\65\t\65\4\66\t\66\4\67\t\67\48\t8\49\t9\4:\t:\4;\t")
        buf.write(";\4<\t<\4=\t=\4>\t>\4?\t?\4@\t@\4A\tA\4B\tB\4C\tC\4D\t")
        buf.write("D\4E\tE\3\2\7\2\u008c\n\2\f\2\16\2\u008f\13\2\3\3\3\3")
        buf.write("\5\3\u0093\n\3\3\4\3\4\3\4\5\4\u0098\n\4\3\5\3\5\3\5\3")
        buf.write("\5\3\5\3\6\3\6\3\7\3\7\5\7\u00a3\n\7\3\b\3\b\3\b\3\t\3")
        buf.write("\t\3\t\3\t\3\t\3\t\5\t\u00ae\n\t\3\n\3\n\3\13\3\13\3\f")
        buf.write("\3\f\3\r\3\r\3\16\3\16\3\17\3\17\3\20\3\20\3\20\3\20\3")
        buf.write("\20\3\20\5\20\u00c2\n\20\3\21\3\21\3\21\3\21\5\21\u00c8")
        buf.write("\n\21\3\22\3\22\3\22\3\22\3\22\3\23\3\23\3\23\3\23\3\23")
        buf.write("\3\23\7\23\u00d5\n\23\f\23\16\23\u00d8\13\23\3\24\3\24")
        buf.write("\3\24\3\24\3\24\5\24\u00df\n\24\3\25\3\25\3\25\3\25\3")
        buf.write("\26\3\26\3\26\3\26\5\26\u00e9\n\26\3\27\3\27\3\30\3\30")
        buf.write("\3\30\3\30\3\30\3\30\7\30\u00f3\n\30\f\30\16\30\u00f6")
        buf.write("\13\30\3\31\3\31\3\31\5\31\u00fb\n\31\3\32\3\32\3\32\3")
        buf.write("\32\3\32\3\32\7\32\u0103\n\32\f\32\16\32\u0106\13\32\3")
        buf.write("\33\3\33\3\33\3\34\5\34\u010c\n\34\3\34\3\34\3\35\3\35")
        buf.write("\3\35\3\35\3\35\3\35\5\35\u0116\n\35\3\36\3\36\3\36\3")
        buf.write("\36\3\36\3\37\3\37\3 \3 \3 \3 \3 \3 \7 \u0125\n \f \16")
        buf.write(" \u0128\13 \3!\3!\3!\3!\3!\3!\7!\u0130\n!\f!\16!\u0133")
        buf.write("\13!\3\"\3\"\5\"\u0137\n\"\3#\3#\3#\3#\3$\3$\3$\5$\u0140")
        buf.write("\n$\3$\3$\3$\5$\u0145\n$\3$\3$\3$\3$\3$\3$\3$\3$\3$\5")
        buf.write("$\u0150\n$\3$\3$\3$\3$\3$\3$\3$\3$\3$\3$\3$\3$\3$\3$\3")
        buf.write("$\3$\3$\3$\3$\3$\3$\3$\3$\3$\3$\3$\3$\3$\3$\3$\3$\3$\3")
        buf.write("$\3$\3$\3$\3$\3$\3$\3$\3$\3$\3$\3$\3$\5$\u017f\n$\3$\3")
        buf.write("$\3$\3$\3$\7$\u0186\n$\f$\16$\u0189\13$\3%\3%\3%\3%\3")
        buf.write("%\3%\3%\3&\3&\3\'\3\'\3(\3(\3)\3)\3*\3*\3+\3+\3,\3,\3")
        buf.write("-\3-\3.\3.\3/\3/\3/\3/\3/\3/\3/\3/\3/\3/\5/\u01ae\n/\3")
        buf.write("\60\3\60\3\60\3\60\3\60\3\60\3\61\3\61\3\61\3\61\3\62")
        buf.write("\3\62\3\62\3\62\3\62\3\62\3\62\3\62\3\62\3\62\3\62\3\62")
        buf.write("\3\62\3\62\3\62\3\62\3\62\3\62\3\62\3\62\5\62\u01ce\n")
        buf.write("\62\3\63\3\63\3\64\3\64\3\65\3\65\3\65\3\65\3\65\3\65")
        buf.write("\3\65\3\65\3\66\3\66\3\66\3\67\3\67\38\38\39\39\59\u01e5")
        buf.write("\n9\39\39\3:\3:\3:\3:\3:\3:\3:\5:\u01f0\n:\3;\3;\3;\3")
        buf.write(";\3;\3;\3;\3;\3;\3;\3;\3;\5;\u01fe\n;\3<\5<\u0201\n<\3")
        buf.write("<\3<\5<\u0205\n<\3<\3<\5<\u0209\n<\3=\3=\3>\3>\3?\5?\u0210")
        buf.write("\n?\3?\3?\3?\5?\u0215\n?\3@\3@\3@\3@\3@\3A\6A\u021d\n")
        buf.write("A\rA\16A\u021e\3B\3B\3B\3C\3C\3D\3D\3E\3E\3E\2\b$.\62")
        buf.write(">@FF\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$&(*,.\60")
        buf.write("\62\64\668:<>@BDFHJLNPRTVXZ\\^`bdfhjlnprtvxz|~\u0080\u0082")
        buf.write("\u0084\u0086\u0088\2\20\3\2\3\4\4\2\16\16  \4\2\7\b\17")
        buf.write("\17\4\2\35\35\37\37\3\2RS\4\2TTVW\3\2]^\4\2@@X\\\4\2F")
        buf.write("FII\4\2ABGH\3\2JK\5\2CDPQSS\7\2\5\17\22\22\25\34!=PP\3")
        buf.write("\2ij\2\u0231\2\u008d\3\2\2\2\4\u0092\3\2\2\2\6\u0097\3")
        buf.write("\2\2\2\b\u0099\3\2\2\2\n\u009e\3\2\2\2\f\u00a2\3\2\2\2")
        buf.write("\16\u00a4\3\2\2\2\20\u00ad\3\2\2\2\22\u00af\3\2\2\2\24")
        buf.write("\u00b1\3\2\2\2\26\u00b3\3\2\2\2\30\u00b5\3\2\2\2\32\u00b7")
        buf.write("\3\2\2\2\34\u00b9\3\2\2\2\36\u00c1\3\2\2\2 \u00c7\3\2")
        buf.write("\2\2\"\u00c9\3\2\2\2$\u00ce\3\2\2\2&\u00de\3\2\2\2(\u00e0")
        buf.write("\3\2\2\2*\u00e8\3\2\2\2,\u00ea\3\2\2\2.\u00ec\3\2\2\2")
        buf.write("\60\u00f7\3\2\2\2\62\u00fc\3\2\2\2\64\u0107\3\2\2\2\66")
        buf.write("\u010b\3\2\2\28\u0115\3\2\2\2:\u0117\3\2\2\2<\u011c\3")
        buf.write("\2\2\2>\u011e\3\2\2\2@\u0129\3\2\2\2B\u0136\3\2\2\2D\u0138")
        buf.write("\3\2\2\2F\u014f\3\2\2\2H\u018a\3\2\2\2J\u0191\3\2\2\2")
        buf.write("L\u0193\3\2\2\2N\u0195\3\2\2\2P\u0197\3\2\2\2R\u0199\3")
        buf.write("\2\2\2T\u019b\3\2\2\2V\u019d\3\2\2\2X\u019f\3\2\2\2Z\u01a1")
        buf.write("\3\2\2\2\\\u01ad\3\2\2\2^\u01af\3\2\2\2`\u01b5\3\2\2\2")
        buf.write("b\u01cd\3\2\2\2d\u01cf\3\2\2\2f\u01d1\3\2\2\2h\u01d3\3")
        buf.write("\2\2\2j\u01db\3\2\2\2l\u01de\3\2\2\2n\u01e0\3\2\2\2p\u01e2")
        buf.write("\3\2\2\2r\u01e8\3\2\2\2t\u01fd\3\2\2\2v\u0200\3\2\2\2")
        buf.write("x\u020a\3\2\2\2z\u020c\3\2\2\2|\u020f\3\2\2\2~\u0216\3")
        buf.write("\2\2\2\u0080\u021c\3\2\2\2\u0082\u0220\3\2\2\2\u0084\u0223")
        buf.write("\3\2\2\2\u0086\u0225\3\2\2\2\u0088\u0227\3\2\2\2\u008a")
        buf.write("\u008c\5\4\3\2\u008b\u008a\3\2\2\2\u008c\u008f\3\2\2\2")
        buf.write("\u008d\u008b\3\2\2\2\u008d\u008e\3\2\2\2\u008e\3\3\2\2")
        buf.write("\2\u008f\u008d\3\2\2\2\u0090\u0093\5\6\4\2\u0091\u0093")
        buf.write("\5\u0082B\2\u0092\u0090\3\2\2\2\u0092\u0091\3\2\2\2\u0093")
        buf.write("\5\3\2\2\2\u0094\u0098\5\b\5\2\u0095\u0098\5\f\7\2\u0096")
        buf.write("\u0098\5\64\33\2\u0097\u0094\3\2\2\2\u0097\u0095\3\2\2")
        buf.write("\2\u0097\u0096\3\2\2\2\u0098\7\3\2\2\2\u0099\u009a\7\6")
        buf.write("\2\2\u009a\u009b\5\n\6\2\u009b\u009c\5F$\2\u009c\u009d")
        buf.write("\5\n\6\2\u009d\t\3\2\2\2\u009e\u009f\t\2\2\2\u009f\13")
        buf.write("\3\2\2\2\u00a0\u00a3\5(\25\2\u00a1\u00a3\5\16\b\2\u00a2")
        buf.write("\u00a0\3\2\2\2\u00a2\u00a1\3\2\2\2\u00a3\r\3\2\2\2\u00a4")
        buf.write("\u00a5\5\20\t\2\u00a5\u00a6\7h\2\2\u00a6\17\3\2\2\2\u00a7")
        buf.write("\u00ae\5\24\13\2\u00a8\u00ae\5\32\16\2\u00a9\u00ae\5\34")
        buf.write("\17\2\u00aa\u00ae\5\36\20\2\u00ab\u00ae\5\"\22\2\u00ac")
        buf.write("\u00ae\5\22\n\2\u00ad\u00a7\3\2\2\2\u00ad\u00a8\3\2\2")
        buf.write("\2\u00ad\u00a9\3\2\2\2\u00ad\u00aa\3\2\2\2\u00ad\u00ab")
        buf.write("\3\2\2\2\u00ad\u00ac\3\2\2\2\u00ae\21\3\2\2\2\u00af\u00b0")
        buf.write("\t\3\2\2\u00b0\23\3\2\2\2\u00b1\u00b2\t\4\2\2\u00b2\25")
        buf.write("\3\2\2\2\u00b3\u00b4\t\5\2\2\u00b4\27\3\2\2\2\u00b5\u00b6")
        buf.write("\7\36\2\2\u00b6\31\3\2\2\2\u00b7\u00b8\7\33\2\2\u00b8")
        buf.write("\33\3\2\2\2\u00b9\u00ba\7\34\2\2\u00ba\35\3\2\2\2\u00bb")
        buf.write("\u00bc\7\23\2\2\u00bc\u00bd\7B\2\2\u00bd\u00be\5 \21\2")
        buf.write("\u00be\u00bf\7A\2\2\u00bf\u00c2\3\2\2\2\u00c0\u00c2\7")
        buf.write("\21\2\2\u00c1\u00bb\3\2\2\2\u00c1\u00c0\3\2\2\2\u00c2")
        buf.write("\37\3\2\2\2\u00c3\u00c8\5\24\13\2\u00c4\u00c8\5\32\16")
        buf.write("\2\u00c5\u00c8\5\34\17\2\u00c6\u00c8\7\21\2\2\u00c7\u00c3")
        buf.write("\3\2\2\2\u00c7\u00c4\3\2\2\2\u00c7\u00c5\3\2\2\2\u00c7")
        buf.write("\u00c6\3\2\2\2\u00c8!\3\2\2\2\u00c9\u00ca\7\35\2\2\u00ca")
        buf.write("\u00cb\7B\2\2\u00cb\u00cc\5$\23\2\u00cc\u00cd\7A\2\2\u00cd")
        buf.write("#\3\2\2\2\u00ce\u00cf\b\23\1\2\u00cf\u00d0\5&\24\2\u00d0")
        buf.write("\u00d6\3\2\2\2\u00d1\u00d2\f\3\2\2\u00d2\u00d3\7b\2\2")
        buf.write("\u00d3\u00d5\5&\24\2\u00d4\u00d1\3\2\2\2\u00d5\u00d8\3")
        buf.write("\2\2\2\u00d6\u00d4\3\2\2\2\u00d6\u00d7\3\2\2\2\u00d7%")
        buf.write("\3\2\2\2\u00d8\u00d6\3\2\2\2\u00d9\u00df\5\24\13\2\u00da")
        buf.write("\u00df\5\32\16\2\u00db\u00df\5\34\17\2\u00dc\u00df\5\36")
        buf.write("\20\2\u00dd\u00df\5\"\22\2\u00de\u00d9\3\2\2\2\u00de\u00da")
        buf.write("\3\2\2\2\u00de\u00db\3\2\2\2\u00de\u00dc\3\2\2\2\u00de")
        buf.write("\u00dd\3\2\2\2\u00df\'\3\2\2\2\u00e0\u00e1\5*\26\2\u00e1")
        buf.write("\u00e2\5.\30\2\u00e2\u00e3\7a\2\2\u00e3)\3\2\2\2\u00e4")
        buf.write("\u00e9\5,\27\2\u00e5\u00e9\5\36\20\2\u00e6\u00e9\5\26")
        buf.write("\f\2\u00e7\u00e9\5\32\16\2\u00e8\u00e4\3\2\2\2\u00e8\u00e5")
        buf.write("\3\2\2\2\u00e8\u00e6\3\2\2\2\u00e8\u00e7\3\2\2\2\u00e9")
        buf.write("+\3\2\2\2\u00ea\u00eb\7\5\2\2\u00eb-\3\2\2\2\u00ec\u00ed")
        buf.write("\b\30\1\2\u00ed\u00ee\5\60\31\2\u00ee\u00f4\3\2\2\2\u00ef")
        buf.write("\u00f0\f\3\2\2\u00f0\u00f1\7b\2\2\u00f1\u00f3\5\60\31")
        buf.write("\2\u00f2\u00ef\3\2\2\2\u00f3\u00f6\3\2\2\2\u00f4\u00f2")
        buf.write("\3\2\2\2\u00f4\u00f5\3\2\2\2\u00f5/\3\2\2\2\u00f6\u00f4")
        buf.write("\3\2\2\2\u00f7\u00fa\7h\2\2\u00f8\u00f9\7@\2\2\u00f9\u00fb")
        buf.write("\5\62\32\2\u00fa\u00f8\3\2\2\2\u00fa\u00fb\3\2\2\2\u00fb")
        buf.write("\61\3\2\2\2\u00fc\u00fd\b\32\1\2\u00fd\u00fe\5F$\2\u00fe")
        buf.write("\u0104\3\2\2\2\u00ff\u0100\f\3\2\2\u0100\u0101\7b\2\2")
        buf.write("\u0101\u0103\5F$\2\u0102\u00ff\3\2\2\2\u0103\u0106\3\2")
        buf.write("\2\2\u0104\u0102\3\2\2\2\u0104\u0105\3\2\2\2\u0105\63")
        buf.write("\3\2\2\2\u0106\u0104\3\2\2\2\u0107\u0108\5\66\34\2\u0108")
        buf.write("\u0109\7a\2\2\u0109\65\3\2\2\2\u010a\u010c\58\35\2\u010b")
        buf.write("\u010a\3\2\2\2\u010b\u010c\3\2\2\2\u010c\u010d\3\2\2\2")
        buf.write("\u010d\u010e\5:\36\2\u010e\67\3\2\2\2\u010f\u0116\5\30")
        buf.write("\r\2\u0110\u0116\5\26\f\2\u0111\u0116\5\24\13\2\u0112")
        buf.write("\u0116\5\34\17\2\u0113\u0116\5\36\20\2\u0114\u0116\5\"")
        buf.write("\22\2\u0115\u010f\3\2\2\2\u0115\u0110\3\2\2\2\u0115\u0111")
        buf.write("\3\2\2\2\u0115\u0112\3\2\2\2\u0115\u0113\3\2\2\2\u0115")
        buf.write("\u0114\3\2\2\2\u01169\3\2\2\2\u0117\u0118\5<\37\2\u0118")
        buf.write("\u0119\7d\2\2\u0119\u011a\5> \2\u011a\u011b\7e\2\2\u011b")
        buf.write(";\3\2\2\2\u011c\u011d\7h\2\2\u011d=\3\2\2\2\u011e\u011f")
        buf.write("\b \1\2\u011f\u0120\5\16\b\2\u0120\u0126\3\2\2\2\u0121")
        buf.write("\u0122\f\3\2\2\u0122\u0123\7b\2\2\u0123\u0125\5\16\b\2")
        buf.write("\u0124\u0121\3\2\2\2\u0125\u0128\3\2\2\2\u0126\u0124\3")
        buf.write("\2\2\2\u0126\u0127\3\2\2\2\u0127?\3\2\2\2\u0128\u0126")
        buf.write("\3\2\2\2\u0129\u012a\b!\1\2\u012a\u012b\5F$\2\u012b\u0131")
        buf.write("\3\2\2\2\u012c\u012d\f\3\2\2\u012d\u012e\7b\2\2\u012e")
        buf.write("\u0130\5F$\2\u012f\u012c\3\2\2\2\u0130\u0133\3\2\2\2\u0131")
        buf.write("\u012f\3\2\2\2\u0131\u0132\3\2\2\2\u0132A\3\2\2\2\u0133")
        buf.write("\u0131\3\2\2\2\u0134\u0137\5F$\2\u0135\u0137\5D#\2\u0136")
        buf.write("\u0134\3\2\2\2\u0136\u0135\3\2\2\2\u0137C\3\2\2\2\u0138")
        buf.write("\u0139\5F$\2\u0139\u013a\7E\2\2\u013a\u013b\5F$\2\u013b")
        buf.write("E\3\2\2\2\u013c\u013d\b$\1\2\u013d\u013f\7f\2\2\u013e")
        buf.write("\u0140\5@!\2\u013f\u013e\3\2\2\2\u013f\u0140\3\2\2\2\u0140")
        buf.write("\u0141\3\2\2\2\u0141\u0150\7g\2\2\u0142\u0144\7d\2\2\u0143")
        buf.write("\u0145\5@!\2\u0144\u0143\3\2\2\2\u0144\u0145\3\2\2\2\u0145")
        buf.write("\u0146\3\2\2\2\u0146\u0150\7e\2\2\u0147\u0148\5Z.\2\u0148")
        buf.write("\u0149\5F$\20\u0149\u0150\3\2\2\2\u014a\u0150\5H%\2\u014b")
        buf.write("\u0150\7h\2\2\u014c\u0150\5\u0088E\2\u014d\u0150\5\u0086")
        buf.write("D\2\u014e\u0150\7\24\2\2\u014f\u013c\3\2\2\2\u014f\u0142")
        buf.write("\3\2\2\2\u014f\u0147\3\2\2\2\u014f\u014a\3\2\2\2\u014f")
        buf.write("\u014b\3\2\2\2\u014f\u014c\3\2\2\2\u014f\u014d\3\2\2\2")
        buf.write("\u014f\u014e\3\2\2\2\u0150\u0187\3\2\2\2\u0151\u0152\f")
        buf.write("\24\2\2\u0152\u0153\7c\2\2\u0153\u0186\5F$\25\u0154\u0155")
        buf.write("\f\17\2\2\u0155\u0156\5N(\2\u0156\u0157\5F$\20\u0157\u0186")
        buf.write("\3\2\2\2\u0158\u0159\f\16\2\2\u0159\u015a\5L\'\2\u015a")
        buf.write("\u015b\5F$\17\u015b\u0186\3\2\2\2\u015c\u015d\f\r\2\2")
        buf.write("\u015d\u015e\5P)\2\u015e\u015f\5F$\16\u015f\u0186\3\2")
        buf.write("\2\2\u0160\u0161\f\f\2\2\u0161\u0162\5V,\2\u0162\u0163")
        buf.write("\5F$\r\u0163\u0186\3\2\2\2\u0164\u0165\f\13\2\2\u0165")
        buf.write("\u0166\5T+\2\u0166\u0167\5F$\f\u0167\u0186\3\2\2\2\u0168")
        buf.write("\u0169\f\n\2\2\u0169\u016a\5X-\2\u016a\u016b\5F$\13\u016b")
        buf.write("\u0186\3\2\2\2\u016c\u016d\f\t\2\2\u016d\u016e\7O\2\2")
        buf.write("\u016e\u016f\5F$\2\u016f\u0170\7E\2\2\u0170\u0171\5F$")
        buf.write("\n\u0171\u0186\3\2\2\2\u0172\u0173\f\b\2\2\u0173\u0174")
        buf.write("\5R*\2\u0174\u0175\5F$\t\u0175\u0186\3\2\2\2\u0176\u0177")
        buf.write("\f\25\2\2\u0177\u0178\7f\2\2\u0178\u0179\5B\"\2\u0179")
        buf.write("\u017a\7g\2\2\u017a\u0186\3\2\2\2\u017b\u017c\f\23\2\2")
        buf.write("\u017c\u017e\7d\2\2\u017d\u017f\5@!\2\u017e\u017d\3\2")
        buf.write("\2\2\u017e\u017f\3\2\2\2\u017f\u0180\3\2\2\2\u0180\u0186")
        buf.write("\7e\2\2\u0181\u0182\f\22\2\2\u0182\u0186\7P\2\2\u0183")
        buf.write("\u0184\f\21\2\2\u0184\u0186\7Q\2\2\u0185\u0151\3\2\2\2")
        buf.write("\u0185\u0154\3\2\2\2\u0185\u0158\3\2\2\2\u0185\u015c\3")
        buf.write("\2\2\2\u0185\u0160\3\2\2\2\u0185\u0164\3\2\2\2\u0185\u0168")
        buf.write("\3\2\2\2\u0185\u016c\3\2\2\2\u0185\u0172\3\2\2\2\u0185")
        buf.write("\u0176\3\2\2\2\u0185\u017b\3\2\2\2\u0185\u0181\3\2\2\2")
        buf.write("\u0185\u0183\3\2\2\2\u0186\u0189\3\2\2\2\u0187\u0185\3")
        buf.write("\2\2\2\u0187\u0188\3\2\2\2\u0188G\3\2\2\2\u0189\u0187")
        buf.write("\3\2\2\2\u018a\u018b\7\26\2\2\u018b\u018c\7d\2\2\u018c")
        buf.write("\u018d\5> \2\u018d\u018e\7e\2\2\u018e\u018f\7E\2\2\u018f")
        buf.write("\u0190\5J&\2\u0190I\3\2\2\2\u0191\u0192\5p9\2\u0192K\3")
        buf.write("\2\2\2\u0193\u0194\t\6\2\2\u0194M\3\2\2\2\u0195\u0196")
        buf.write("\t\7\2\2\u0196O\3\2\2\2\u0197\u0198\t\b\2\2\u0198Q\3\2")
        buf.write("\2\2\u0199\u019a\t\t\2\2\u019aS\3\2\2\2\u019b\u019c\t")
        buf.write("\n\2\2\u019cU\3\2\2\2\u019d\u019e\t\13\2\2\u019eW\3\2")
        buf.write("\2\2\u019f\u01a0\t\f\2\2\u01a0Y\3\2\2\2\u01a1\u01a2\t")
        buf.write("\r\2\2\u01a2[\3\2\2\2\u01a3\u01ae\5j\66\2\u01a4\u01ae")
        buf.write("\5l\67\2\u01a5\u01ae\5n8\2\u01a6\u01ae\5p9\2\u01a7\u01ae")
        buf.write("\5r:\2\u01a8\u01ae\5^\60\2\u01a9\u01ae\5t;\2\u01aa\u01ae")
        buf.write("\5b\62\2\u01ab\u01ae\5h\65\2\u01ac\u01ae\5`\61\2\u01ad")
        buf.write("\u01a3\3\2\2\2\u01ad\u01a4\3\2\2\2\u01ad\u01a5\3\2\2\2")
        buf.write("\u01ad\u01a6\3\2\2\2\u01ad\u01a7\3\2\2\2\u01ad\u01a8\3")
        buf.write("\2\2\2\u01ad\u01a9\3\2\2\2\u01ad\u01aa\3\2\2\2\u01ad\u01ab")
        buf.write("\3\2\2\2\u01ad\u01ac\3\2\2\2\u01ae]\3\2\2\2\u01af\u01b0")
        buf.write("\7>\2\2\u01b0\u01b1\7d\2\2\u01b1\u01b2\5F$\2\u01b2\u01b3")
        buf.write("\7e\2\2\u01b3\u01b4\5\\/\2\u01b4_\3\2\2\2\u01b5\u01b6")
        buf.write("\7\25\2\2\u01b6\u01b7\5F$\2\u01b7\u01b8\7a\2\2\u01b8a")
        buf.write("\3\2\2\2\u01b9\u01ba\7;\2\2\u01ba\u01bb\7d\2\2\u01bb\u01bc")
        buf.write("\5F$\2\u01bc\u01bd\7e\2\2\u01bd\u01be\7_\2\2\u01be\u01bf")
        buf.write("\5d\63\2\u01bf\u01c0\7`\2\2\u01c0\u01ce\3\2\2\2\u01c1")
        buf.write("\u01c2\7;\2\2\u01c2\u01c3\7d\2\2\u01c3\u01c4\5F$\2\u01c4")
        buf.write("\u01c5\7e\2\2\u01c5\u01c6\7_\2\2\u01c6\u01c7\5d\63\2\u01c7")
        buf.write("\u01c8\7`\2\2\u01c8\u01c9\7=\2\2\u01c9\u01ca\7_\2\2\u01ca")
        buf.write("\u01cb\5f\64\2\u01cb\u01cc\7`\2\2\u01cc\u01ce\3\2\2\2")
        buf.write("\u01cd\u01b9\3\2\2\2\u01cd\u01c1\3\2\2\2\u01cec\3\2\2")
        buf.write("\2\u01cf\u01d0\5\u0080A\2\u01d0e\3\2\2\2\u01d1\u01d2\5")
        buf.write("\u0080A\2\u01d2g\3\2\2\2\u01d3\u01d4\7<\2\2\u01d4\u01d5")
        buf.write("\7d\2\2\u01d5\u01d6\5F$\2\u01d6\u01d7\7e\2\2\u01d7\u01d8")
        buf.write("\7_\2\2\u01d8\u01d9\5\u0080A\2\u01d9\u01da\7`\2\2\u01da")
        buf.write("i\3\2\2\2\u01db\u01dc\5F$\2\u01dc\u01dd\7a\2\2\u01ddk")
        buf.write("\3\2\2\2\u01de\u01df\7a\2\2\u01dfm\3\2\2\2\u01e0\u01e1")
        buf.write("\5(\25\2\u01e1o\3\2\2\2\u01e2\u01e4\7_\2\2\u01e3\u01e5")
        buf.write("\5\u0080A\2\u01e4\u01e3\3\2\2\2\u01e4\u01e5\3\2\2\2\u01e5")
        buf.write("\u01e6\3\2\2\2\u01e6\u01e7\7`\2\2\u01e7q\3\2\2\2\u01e8")
        buf.write("\u01e9\7\t\2\2\u01e9\u01ea\7d\2\2\u01ea\u01eb\5F$\2\u01eb")
        buf.write("\u01ec\7e\2\2\u01ec\u01ef\5\\/\2\u01ed\u01ee\7\n\2\2\u01ee")
        buf.write("\u01f0\5\\/\2\u01ef\u01ed\3\2\2\2\u01ef\u01f0\3\2\2\2")
        buf.write("\u01f0s\3\2\2\2\u01f1\u01f2\7\13\2\2\u01f2\u01f3\7d\2")
        buf.write("\2\u01f3\u01f4\5v<\2\u01f4\u01f5\7e\2\2\u01f5\u01f6\5")
        buf.write("\\/\2\u01f6\u01fe\3\2\2\2\u01f7\u01f8\7\13\2\2\u01f8\u01f9")
        buf.write("\7d\2\2\u01f9\u01fa\5~@\2\u01fa\u01fb\7e\2\2\u01fb\u01fc")
        buf.write("\5\\/\2\u01fc\u01fe\3\2\2\2\u01fd\u01f1\3\2\2\2\u01fd")
        buf.write("\u01f7\3\2\2\2\u01feu\3\2\2\2\u01ff\u0201\5|?\2\u0200")
        buf.write("\u01ff\3\2\2\2\u0200\u0201\3\2\2\2\u0201\u0202\3\2\2\2")
        buf.write("\u0202\u0204\7E\2\2\u0203\u0205\5x=\2\u0204\u0203\3\2")
        buf.write("\2\2\u0204\u0205\3\2\2\2\u0205\u0206\3\2\2\2\u0206\u0208")
        buf.write("\7E\2\2\u0207\u0209\5z>\2\u0208\u0207\3\2\2\2\u0208\u0209")
        buf.write("\3\2\2\2\u0209w\3\2\2\2\u020a\u020b\5F$\2\u020by\3\2\2")
        buf.write("\2\u020c\u020d\5F$\2\u020d{\3\2\2\2\u020e\u0210\7\5\2")
        buf.write("\2\u020f\u020e\3\2\2\2\u020f\u0210\3\2\2\2\u0210\u0211")
        buf.write("\3\2\2\2\u0211\u0214\7h\2\2\u0212\u0213\7@\2\2\u0213\u0215")
        buf.write("\5F$\2\u0214\u0212\3\2\2\2\u0214\u0215\3\2\2\2\u0215}")
        buf.write("\3\2\2\2\u0216\u0217\5 \21\2\u0217\u0218\7h\2\2\u0218")
        buf.write("\u0219\7\22\2\2\u0219\u021a\5F$\2\u021a\177\3\2\2\2\u021b")
        buf.write("\u021d\5\\/\2\u021c\u021b\3\2\2\2\u021d\u021e\3\2\2\2")
        buf.write("\u021e\u021c\3\2\2\2\u021e\u021f\3\2\2\2\u021f\u0081\3")
        buf.write("\2\2\2\u0220\u0221\5\66\34\2\u0221\u0222\5\u0084C\2\u0222")
        buf.write("\u0083\3\2\2\2\u0223\u0224\5p9\2\u0224\u0085\3\2\2\2\u0225")
        buf.write("\u0226\t\16\2\2\u0226\u0087\3\2\2\2\u0227\u0228\t\17\2")
        buf.write("\2\u0228\u0089\3\2\2\2%\u008d\u0092\u0097\u00a2\u00ad")
        buf.write("\u00c1\u00c7\u00d6\u00de\u00e8\u00f4\u00fa\u0104\u010b")
        buf.write("\u0115\u0126\u0131\u0136\u013f\u0144\u014f\u017e\u0185")
        buf.write("\u0187\u01ad\u01cd\u01e4\u01ef\u01fd\u0200\u0204\u0208")
        buf.write("\u020f\u0214\u021e")
        return buf.getvalue()


class QcodeParser ( Parser ):

    grammarFileName = "Qcode.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'\"'", "'''", "'let'", "'include'", "'int'", 
                     "'bool'", "'if'", "'else'", "'for'", "'lib'", "'qrunes'", 
                     "'avar'", "'double'", "'default'", "'map'", "'in'", 
                     "'vector'", "'Pi'", "'return'", "'lambda'", "'break'", 
                     "'continue'", "'true'", "'false'", "'qubit'", "'cbit'", 
                     "'circuit'", "'qprog'", "'variationalCircuit'", "'hamiltonian'", 
                     "'VQG_CNOT'", "'VQG_RZ'", "'VQG_RX'", "'H'", "'X'", 
                     "'NOT'", "'T'", "'S'", "'Y'", "'Z'", "'X1'", "'Y1'", 
                     "'Z1'", "'U4'", "'RX'", "'RY'", "'RZ'", "'Toffoli'", 
                     "'CNOT'", "'CZ'", "'CR'", "'CU'", "'iSWAP'", "'apply_QGate'", 
                     "'measure'", "'measure_all'", "'qif'", "'qwhile'", 
                     "'qelse'", "'while'", "'#'", "'='", "'>'", "'<'", "'!'", 
                     "'~'", "':'", "'=='", "'<='", "'>='", "'!='", "'&&'", 
                     "'||'", "'&'", "'^'", "'|'", "'?'", "'++'", "'--'", 
                     "'+'", "'-'", "'*'", "'**'", "'/'", "'%'", "'+='", 
                     "'-='", "'*='", "'/='", "'%='", "'<<'", "'>>'", "'{'", 
                     "'}'", "';'", "','", "'.'", "'('", "')'", "'['", "']'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "LET", "INCLUDE", 
                      "INT", "BOOL", "IF", "ELSE", "FOR", "LIB", "QRUNES", 
                      "AVAR", "DOUBLE", "DEFAULT", "MAP", "IN", "VECTOR", 
                      "PI", "RETURN", "LAMBDA", "BREAK", "CONTINUE", "TRUE", 
                      "FALSE", "QUBIT", "CBIT", "CIRCUIT", "QPROG", "VARIATIONALCIRCUIT", 
                      "HAMILTONIAN", "VQG_CNOT_VCGEN", "VQG_RZ_VCGEN", "VQG_RX_VCGEN", 
                      "H_GATE", "X_GATE", "NOT_GATE", "T_GATE", "S_GATE", 
                      "Y_GATE", "Z_GATE", "X1_GATE", "Y1_GATE", "Z1_GATE", 
                      "U4_GATE", "RX_GATE", "RY_GATE", "RZ_GATE", "TOFFOLI_GATE", 
                      "CNOT_GATE", "CZ_GATE", "CR_GATE", "CU_GATE", "ISWAP", 
                      "APPLY_QGATE", "MEASURE", "MEASUREALL", "QIF", "QWHILE", 
                      "QELSE", "WHILE", "SHARP_SIGN", "ASSIGN", "GT", "LT", 
                      "BANG", "TILDE", "COLON", "EQUAL", "LE", "GE", "NOTEQUAL", 
                      "LOGIC_AND", "LOGIC_OR", "AND", "EXCLU", "INCLU", 
                      "QUE_MARK", "INC", "DEC", "ADD", "SUB", "MUL", "POW", 
                      "DIV", "MOD", "ADD_ASSIGN", "SUB_ASSIGN", "MUL_ASSIGN", 
                      "DIV_ASSIGN", "MOD_ASSIGN", "SHIFT_LEFT", "SHIFT_RIGHT", 
                      "LBRACE", "RBRACE", "SEMI", "COMMA", "DOT", "LPAREN", 
                      "RPAREN", "LBRACK", "RBRACK", "Identifier", "Integer_Literal", 
                      "Double_Literal", "Digit_Sequence", "WhiteSpace", 
                      "SingleLineComment", "MultiLinesComment" ]

    RULE_qrunes = 0
    RULE_lang_unit = 1
    RULE_declaration = 2
    RULE_include_declaration = 3
    RULE_include_sign = 4
    RULE_variable_declaration = 5
    RULE_parameter_declaration = 6
    RULE_parameter_specifier = 7
    RULE_quantum_alg_built_in_type = 8
    RULE_auxiliary_primary_type = 9
    RULE_quantum_circuit_type = 10
    RULE_quantum_prog_type = 11
    RULE_quantum_primary_type = 12
    RULE_classical_primary_type = 13
    RULE_array_construct_type = 14
    RULE_construct_primary_type = 15
    RULE_call_back_construct_type = 16
    RULE_call_back_primary_type_list = 17
    RULE_call_back_primary_type = 18
    RULE_declaration_variable = 19
    RULE_variable_decl_specifier = 20
    RULE_common_specifier = 21
    RULE_init_declaratorlist = 22
    RULE_variable_declarator = 23
    RULE_variableInitializer = 24
    RULE_function_declaration = 25
    RULE_declarate_function = 26
    RULE_function_return_type_declarator = 27
    RULE_function_declarator = 28
    RULE_function_name = 29
    RULE_parameter_decl_list = 30
    RULE_expression_list = 31
    RULE_vector_expression = 32
    RULE_vector_slice = 33
    RULE_single_expression = 34
    RULE_lambda_exp = 35
    RULE_lambda_body = 36
    RULE_additive_op = 37
    RULE_multiplicative_op = 38
    RULE_shift_op = 39
    RULE_assign_op = 40
    RULE_equal_op = 41
    RULE_relationship_op = 42
    RULE_logic_op = 43
    RULE_unary_op = 44
    RULE_statement = 45
    RULE_while_statement = 46
    RULE_return_statement = 47
    RULE_qif_statement = 48
    RULE_qif_true_branch = 49
    RULE_qif_false_branch = 50
    RULE_qwhile_statement = 51
    RULE_expression_statement = 52
    RULE_empty_statement = 53
    RULE_declaration_variable_statement = 54
    RULE_compound_statement = 55
    RULE_select_statement = 56
    RULE_iterate_statement = 57
    RULE_for_stmt = 58
    RULE_for_step = 59
    RULE_for_condition = 60
    RULE_for_start = 61
    RULE_inhanced_for_stmt = 62
    RULE_statement_list = 63
    RULE_function_definition = 64
    RULE_function_body = 65
    RULE_key_words = 66
    RULE_constant = 67

    ruleNames =  [ "qrunes", "lang_unit", "declaration", "include_declaration", 
                   "include_sign", "variable_declaration", "parameter_declaration", 
                   "parameter_specifier", "quantum_alg_built_in_type", "auxiliary_primary_type", 
                   "quantum_circuit_type", "quantum_prog_type", "quantum_primary_type", 
                   "classical_primary_type", "array_construct_type", "construct_primary_type", 
                   "call_back_construct_type", "call_back_primary_type_list", 
                   "call_back_primary_type", "declaration_variable", "variable_decl_specifier", 
                   "common_specifier", "init_declaratorlist", "variable_declarator", 
                   "variableInitializer", "function_declaration", "declarate_function", 
                   "function_return_type_declarator", "function_declarator", 
                   "function_name", "parameter_decl_list", "expression_list", 
                   "vector_expression", "vector_slice", "single_expression", 
                   "lambda_exp", "lambda_body", "additive_op", "multiplicative_op", 
                   "shift_op", "assign_op", "equal_op", "relationship_op", 
                   "logic_op", "unary_op", "statement", "while_statement", 
                   "return_statement", "qif_statement", "qif_true_branch", 
                   "qif_false_branch", "qwhile_statement", "expression_statement", 
                   "empty_statement", "declaration_variable_statement", 
                   "compound_statement", "select_statement", "iterate_statement", 
                   "for_stmt", "for_step", "for_condition", "for_start", 
                   "inhanced_for_stmt", "statement_list", "function_definition", 
                   "function_body", "key_words", "constant" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    LET=3
    INCLUDE=4
    INT=5
    BOOL=6
    IF=7
    ELSE=8
    FOR=9
    LIB=10
    QRUNES=11
    AVAR=12
    DOUBLE=13
    DEFAULT=14
    MAP=15
    IN=16
    VECTOR=17
    PI=18
    RETURN=19
    LAMBDA=20
    BREAK=21
    CONTINUE=22
    TRUE=23
    FALSE=24
    QUBIT=25
    CBIT=26
    CIRCUIT=27
    QPROG=28
    VARIATIONALCIRCUIT=29
    HAMILTONIAN=30
    VQG_CNOT_VCGEN=31
    VQG_RZ_VCGEN=32
    VQG_RX_VCGEN=33
    H_GATE=34
    X_GATE=35
    NOT_GATE=36
    T_GATE=37
    S_GATE=38
    Y_GATE=39
    Z_GATE=40
    X1_GATE=41
    Y1_GATE=42
    Z1_GATE=43
    U4_GATE=44
    RX_GATE=45
    RY_GATE=46
    RZ_GATE=47
    TOFFOLI_GATE=48
    CNOT_GATE=49
    CZ_GATE=50
    CR_GATE=51
    CU_GATE=52
    ISWAP=53
    APPLY_QGATE=54
    MEASURE=55
    MEASUREALL=56
    QIF=57
    QWHILE=58
    QELSE=59
    WHILE=60
    SHARP_SIGN=61
    ASSIGN=62
    GT=63
    LT=64
    BANG=65
    TILDE=66
    COLON=67
    EQUAL=68
    LE=69
    GE=70
    NOTEQUAL=71
    LOGIC_AND=72
    LOGIC_OR=73
    AND=74
    EXCLU=75
    INCLU=76
    QUE_MARK=77
    INC=78
    DEC=79
    ADD=80
    SUB=81
    MUL=82
    POW=83
    DIV=84
    MOD=85
    ADD_ASSIGN=86
    SUB_ASSIGN=87
    MUL_ASSIGN=88
    DIV_ASSIGN=89
    MOD_ASSIGN=90
    SHIFT_LEFT=91
    SHIFT_RIGHT=92
    LBRACE=93
    RBRACE=94
    SEMI=95
    COMMA=96
    DOT=97
    LPAREN=98
    RPAREN=99
    LBRACK=100
    RBRACK=101
    Identifier=102
    Integer_Literal=103
    Double_Literal=104
    Digit_Sequence=105
    WhiteSpace=106
    SingleLineComment=107
    MultiLinesComment=108

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class QrunesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def lang_unit(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QcodeParser.Lang_unitContext)
            else:
                return self.getTypedRuleContext(QcodeParser.Lang_unitContext,i)


        def getRuleIndex(self):
            return QcodeParser.RULE_qrunes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQrunes" ):
                listener.enterQrunes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQrunes" ):
                listener.exitQrunes(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQrunes" ):
                return visitor.visitQrunes(self)
            else:
                return visitor.visitChildren(self)




    def qrunes(self):

        localctx = QcodeParser.QrunesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_qrunes)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 139
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << QcodeParser.LET) | (1 << QcodeParser.INCLUDE) | (1 << QcodeParser.INT) | (1 << QcodeParser.BOOL) | (1 << QcodeParser.AVAR) | (1 << QcodeParser.DOUBLE) | (1 << QcodeParser.MAP) | (1 << QcodeParser.VECTOR) | (1 << QcodeParser.QUBIT) | (1 << QcodeParser.CBIT) | (1 << QcodeParser.CIRCUIT) | (1 << QcodeParser.QPROG) | (1 << QcodeParser.VARIATIONALCIRCUIT) | (1 << QcodeParser.HAMILTONIAN))) != 0) or _la==QcodeParser.Identifier:
                self.state = 136
                self.lang_unit()
                self.state = 141
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Lang_unitContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def declaration(self):
            return self.getTypedRuleContext(QcodeParser.DeclarationContext,0)


        def function_definition(self):
            return self.getTypedRuleContext(QcodeParser.Function_definitionContext,0)


        def getRuleIndex(self):
            return QcodeParser.RULE_lang_unit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLang_unit" ):
                listener.enterLang_unit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLang_unit" ):
                listener.exitLang_unit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLang_unit" ):
                return visitor.visitLang_unit(self)
            else:
                return visitor.visitChildren(self)




    def lang_unit(self):

        localctx = QcodeParser.Lang_unitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_lang_unit)
        try:
            self.state = 144
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 142
                self.declaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 143
                self.function_definition()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DeclarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def include_declaration(self):
            return self.getTypedRuleContext(QcodeParser.Include_declarationContext,0)


        def variable_declaration(self):
            return self.getTypedRuleContext(QcodeParser.Variable_declarationContext,0)


        def function_declaration(self):
            return self.getTypedRuleContext(QcodeParser.Function_declarationContext,0)


        def getRuleIndex(self):
            return QcodeParser.RULE_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclaration" ):
                listener.enterDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclaration" ):
                listener.exitDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeclaration" ):
                return visitor.visitDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def declaration(self):

        localctx = QcodeParser.DeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_declaration)
        try:
            self.state = 149
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 146
                self.include_declaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 147
                self.variable_declaration()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 148
                self.function_declaration()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Include_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INCLUDE(self):
            return self.getToken(QcodeParser.INCLUDE, 0)

        def include_sign(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QcodeParser.Include_signContext)
            else:
                return self.getTypedRuleContext(QcodeParser.Include_signContext,i)


        def single_expression(self):
            return self.getTypedRuleContext(QcodeParser.Single_expressionContext,0)


        def getRuleIndex(self):
            return QcodeParser.RULE_include_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInclude_declaration" ):
                listener.enterInclude_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInclude_declaration" ):
                listener.exitInclude_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInclude_declaration" ):
                return visitor.visitInclude_declaration(self)
            else:
                return visitor.visitChildren(self)




    def include_declaration(self):

        localctx = QcodeParser.Include_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_include_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 151
            self.match(QcodeParser.INCLUDE)
            self.state = 152
            self.include_sign()
            self.state = 153
            self.single_expression(0)
            self.state = 154
            self.include_sign()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Include_signContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return QcodeParser.RULE_include_sign

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInclude_sign" ):
                listener.enterInclude_sign(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInclude_sign" ):
                listener.exitInclude_sign(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInclude_sign" ):
                return visitor.visitInclude_sign(self)
            else:
                return visitor.visitChildren(self)




    def include_sign(self):

        localctx = QcodeParser.Include_signContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_include_sign)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 156
            _la = self._input.LA(1)
            if not(_la==QcodeParser.T__0 or _la==QcodeParser.T__1):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Variable_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def declaration_variable(self):
            return self.getTypedRuleContext(QcodeParser.Declaration_variableContext,0)


        def parameter_declaration(self):
            return self.getTypedRuleContext(QcodeParser.Parameter_declarationContext,0)


        def getRuleIndex(self):
            return QcodeParser.RULE_variable_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariable_declaration" ):
                listener.enterVariable_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariable_declaration" ):
                listener.exitVariable_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariable_declaration" ):
                return visitor.visitVariable_declaration(self)
            else:
                return visitor.visitChildren(self)




    def variable_declaration(self):

        localctx = QcodeParser.Variable_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_variable_declaration)
        try:
            self.state = 160
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 158
                self.declaration_variable()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 159
                self.parameter_declaration()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Parameter_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def parameter_specifier(self):
            return self.getTypedRuleContext(QcodeParser.Parameter_specifierContext,0)


        def Identifier(self):
            return self.getToken(QcodeParser.Identifier, 0)

        def getRuleIndex(self):
            return QcodeParser.RULE_parameter_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameter_declaration" ):
                listener.enterParameter_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameter_declaration" ):
                listener.exitParameter_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameter_declaration" ):
                return visitor.visitParameter_declaration(self)
            else:
                return visitor.visitChildren(self)




    def parameter_declaration(self):

        localctx = QcodeParser.Parameter_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_parameter_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 162
            self.parameter_specifier()
            self.state = 163
            self.match(QcodeParser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Parameter_specifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def auxiliary_primary_type(self):
            return self.getTypedRuleContext(QcodeParser.Auxiliary_primary_typeContext,0)


        def quantum_primary_type(self):
            return self.getTypedRuleContext(QcodeParser.Quantum_primary_typeContext,0)


        def classical_primary_type(self):
            return self.getTypedRuleContext(QcodeParser.Classical_primary_typeContext,0)


        def array_construct_type(self):
            return self.getTypedRuleContext(QcodeParser.Array_construct_typeContext,0)


        def call_back_construct_type(self):
            return self.getTypedRuleContext(QcodeParser.Call_back_construct_typeContext,0)


        def quantum_alg_built_in_type(self):
            return self.getTypedRuleContext(QcodeParser.Quantum_alg_built_in_typeContext,0)


        def getRuleIndex(self):
            return QcodeParser.RULE_parameter_specifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameter_specifier" ):
                listener.enterParameter_specifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameter_specifier" ):
                listener.exitParameter_specifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameter_specifier" ):
                return visitor.visitParameter_specifier(self)
            else:
                return visitor.visitChildren(self)




    def parameter_specifier(self):

        localctx = QcodeParser.Parameter_specifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_parameter_specifier)
        try:
            self.state = 171
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [QcodeParser.INT, QcodeParser.BOOL, QcodeParser.DOUBLE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 165
                self.auxiliary_primary_type()
                pass
            elif token in [QcodeParser.QUBIT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 166
                self.quantum_primary_type()
                pass
            elif token in [QcodeParser.CBIT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 167
                self.classical_primary_type()
                pass
            elif token in [QcodeParser.MAP, QcodeParser.VECTOR]:
                self.enterOuterAlt(localctx, 4)
                self.state = 168
                self.array_construct_type()
                pass
            elif token in [QcodeParser.CIRCUIT]:
                self.enterOuterAlt(localctx, 5)
                self.state = 169
                self.call_back_construct_type()
                pass
            elif token in [QcodeParser.AVAR, QcodeParser.HAMILTONIAN]:
                self.enterOuterAlt(localctx, 6)
                self.state = 170
                self.quantum_alg_built_in_type()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Quantum_alg_built_in_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HAMILTONIAN(self):
            return self.getToken(QcodeParser.HAMILTONIAN, 0)

        def AVAR(self):
            return self.getToken(QcodeParser.AVAR, 0)

        def getRuleIndex(self):
            return QcodeParser.RULE_quantum_alg_built_in_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuantum_alg_built_in_type" ):
                listener.enterQuantum_alg_built_in_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuantum_alg_built_in_type" ):
                listener.exitQuantum_alg_built_in_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQuantum_alg_built_in_type" ):
                return visitor.visitQuantum_alg_built_in_type(self)
            else:
                return visitor.visitChildren(self)




    def quantum_alg_built_in_type(self):

        localctx = QcodeParser.Quantum_alg_built_in_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_quantum_alg_built_in_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 173
            _la = self._input.LA(1)
            if not(_la==QcodeParser.AVAR or _la==QcodeParser.HAMILTONIAN):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Auxiliary_primary_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT(self):
            return self.getToken(QcodeParser.INT, 0)

        def DOUBLE(self):
            return self.getToken(QcodeParser.DOUBLE, 0)

        def BOOL(self):
            return self.getToken(QcodeParser.BOOL, 0)

        def getRuleIndex(self):
            return QcodeParser.RULE_auxiliary_primary_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAuxiliary_primary_type" ):
                listener.enterAuxiliary_primary_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAuxiliary_primary_type" ):
                listener.exitAuxiliary_primary_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAuxiliary_primary_type" ):
                return visitor.visitAuxiliary_primary_type(self)
            else:
                return visitor.visitChildren(self)




    def auxiliary_primary_type(self):

        localctx = QcodeParser.Auxiliary_primary_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_auxiliary_primary_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 175
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << QcodeParser.INT) | (1 << QcodeParser.BOOL) | (1 << QcodeParser.DOUBLE))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Quantum_circuit_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CIRCUIT(self):
            return self.getToken(QcodeParser.CIRCUIT, 0)

        def VARIATIONALCIRCUIT(self):
            return self.getToken(QcodeParser.VARIATIONALCIRCUIT, 0)

        def getRuleIndex(self):
            return QcodeParser.RULE_quantum_circuit_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuantum_circuit_type" ):
                listener.enterQuantum_circuit_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuantum_circuit_type" ):
                listener.exitQuantum_circuit_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQuantum_circuit_type" ):
                return visitor.visitQuantum_circuit_type(self)
            else:
                return visitor.visitChildren(self)




    def quantum_circuit_type(self):

        localctx = QcodeParser.Quantum_circuit_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_quantum_circuit_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 177
            _la = self._input.LA(1)
            if not(_la==QcodeParser.CIRCUIT or _la==QcodeParser.VARIATIONALCIRCUIT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Quantum_prog_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def QPROG(self):
            return self.getToken(QcodeParser.QPROG, 0)

        def getRuleIndex(self):
            return QcodeParser.RULE_quantum_prog_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuantum_prog_type" ):
                listener.enterQuantum_prog_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuantum_prog_type" ):
                listener.exitQuantum_prog_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQuantum_prog_type" ):
                return visitor.visitQuantum_prog_type(self)
            else:
                return visitor.visitChildren(self)




    def quantum_prog_type(self):

        localctx = QcodeParser.Quantum_prog_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_quantum_prog_type)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 179
            self.match(QcodeParser.QPROG)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Quantum_primary_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def QUBIT(self):
            return self.getToken(QcodeParser.QUBIT, 0)

        def getRuleIndex(self):
            return QcodeParser.RULE_quantum_primary_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuantum_primary_type" ):
                listener.enterQuantum_primary_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuantum_primary_type" ):
                listener.exitQuantum_primary_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQuantum_primary_type" ):
                return visitor.visitQuantum_primary_type(self)
            else:
                return visitor.visitChildren(self)




    def quantum_primary_type(self):

        localctx = QcodeParser.Quantum_primary_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_quantum_primary_type)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 181
            self.match(QcodeParser.QUBIT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Classical_primary_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CBIT(self):
            return self.getToken(QcodeParser.CBIT, 0)

        def getRuleIndex(self):
            return QcodeParser.RULE_classical_primary_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassical_primary_type" ):
                listener.enterClassical_primary_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassical_primary_type" ):
                listener.exitClassical_primary_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassical_primary_type" ):
                return visitor.visitClassical_primary_type(self)
            else:
                return visitor.visitChildren(self)




    def classical_primary_type(self):

        localctx = QcodeParser.Classical_primary_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_classical_primary_type)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 183
            self.match(QcodeParser.CBIT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Array_construct_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VECTOR(self):
            return self.getToken(QcodeParser.VECTOR, 0)

        def LT(self):
            return self.getToken(QcodeParser.LT, 0)

        def construct_primary_type(self):
            return self.getTypedRuleContext(QcodeParser.Construct_primary_typeContext,0)


        def GT(self):
            return self.getToken(QcodeParser.GT, 0)

        def MAP(self):
            return self.getToken(QcodeParser.MAP, 0)

        def getRuleIndex(self):
            return QcodeParser.RULE_array_construct_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArray_construct_type" ):
                listener.enterArray_construct_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArray_construct_type" ):
                listener.exitArray_construct_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArray_construct_type" ):
                return visitor.visitArray_construct_type(self)
            else:
                return visitor.visitChildren(self)




    def array_construct_type(self):

        localctx = QcodeParser.Array_construct_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_array_construct_type)
        try:
            self.state = 191
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [QcodeParser.VECTOR]:
                self.enterOuterAlt(localctx, 1)
                self.state = 185
                self.match(QcodeParser.VECTOR)
                self.state = 186
                self.match(QcodeParser.LT)
                self.state = 187
                self.construct_primary_type()
                self.state = 188
                self.match(QcodeParser.GT)
                pass
            elif token in [QcodeParser.MAP]:
                self.enterOuterAlt(localctx, 2)
                self.state = 190
                self.match(QcodeParser.MAP)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Construct_primary_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def auxiliary_primary_type(self):
            return self.getTypedRuleContext(QcodeParser.Auxiliary_primary_typeContext,0)


        def quantum_primary_type(self):
            return self.getTypedRuleContext(QcodeParser.Quantum_primary_typeContext,0)


        def classical_primary_type(self):
            return self.getTypedRuleContext(QcodeParser.Classical_primary_typeContext,0)


        def MAP(self):
            return self.getToken(QcodeParser.MAP, 0)

        def getRuleIndex(self):
            return QcodeParser.RULE_construct_primary_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstruct_primary_type" ):
                listener.enterConstruct_primary_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstruct_primary_type" ):
                listener.exitConstruct_primary_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstruct_primary_type" ):
                return visitor.visitConstruct_primary_type(self)
            else:
                return visitor.visitChildren(self)




    def construct_primary_type(self):

        localctx = QcodeParser.Construct_primary_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_construct_primary_type)
        try:
            self.state = 197
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [QcodeParser.INT, QcodeParser.BOOL, QcodeParser.DOUBLE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 193
                self.auxiliary_primary_type()
                pass
            elif token in [QcodeParser.QUBIT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 194
                self.quantum_primary_type()
                pass
            elif token in [QcodeParser.CBIT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 195
                self.classical_primary_type()
                pass
            elif token in [QcodeParser.MAP]:
                self.enterOuterAlt(localctx, 4)
                self.state = 196
                self.match(QcodeParser.MAP)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Call_back_construct_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CIRCUIT(self):
            return self.getToken(QcodeParser.CIRCUIT, 0)

        def LT(self):
            return self.getToken(QcodeParser.LT, 0)

        def call_back_primary_type_list(self):
            return self.getTypedRuleContext(QcodeParser.Call_back_primary_type_listContext,0)


        def GT(self):
            return self.getToken(QcodeParser.GT, 0)

        def getRuleIndex(self):
            return QcodeParser.RULE_call_back_construct_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCall_back_construct_type" ):
                listener.enterCall_back_construct_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCall_back_construct_type" ):
                listener.exitCall_back_construct_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCall_back_construct_type" ):
                return visitor.visitCall_back_construct_type(self)
            else:
                return visitor.visitChildren(self)




    def call_back_construct_type(self):

        localctx = QcodeParser.Call_back_construct_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_call_back_construct_type)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 199
            self.match(QcodeParser.CIRCUIT)
            self.state = 200
            self.match(QcodeParser.LT)
            self.state = 201
            self.call_back_primary_type_list(0)
            self.state = 202
            self.match(QcodeParser.GT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Call_back_primary_type_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def call_back_primary_type(self):
            return self.getTypedRuleContext(QcodeParser.Call_back_primary_typeContext,0)


        def call_back_primary_type_list(self):
            return self.getTypedRuleContext(QcodeParser.Call_back_primary_type_listContext,0)


        def COMMA(self):
            return self.getToken(QcodeParser.COMMA, 0)

        def getRuleIndex(self):
            return QcodeParser.RULE_call_back_primary_type_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCall_back_primary_type_list" ):
                listener.enterCall_back_primary_type_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCall_back_primary_type_list" ):
                listener.exitCall_back_primary_type_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCall_back_primary_type_list" ):
                return visitor.visitCall_back_primary_type_list(self)
            else:
                return visitor.visitChildren(self)



    def call_back_primary_type_list(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = QcodeParser.Call_back_primary_type_listContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 34
        self.enterRecursionRule(localctx, 34, self.RULE_call_back_primary_type_list, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 205
            self.call_back_primary_type()
            self._ctx.stop = self._input.LT(-1)
            self.state = 212
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,7,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = QcodeParser.Call_back_primary_type_listContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_call_back_primary_type_list)
                    self.state = 207
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 208
                    self.match(QcodeParser.COMMA)
                    self.state = 209
                    self.call_back_primary_type() 
                self.state = 214
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,7,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class Call_back_primary_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def auxiliary_primary_type(self):
            return self.getTypedRuleContext(QcodeParser.Auxiliary_primary_typeContext,0)


        def quantum_primary_type(self):
            return self.getTypedRuleContext(QcodeParser.Quantum_primary_typeContext,0)


        def classical_primary_type(self):
            return self.getTypedRuleContext(QcodeParser.Classical_primary_typeContext,0)


        def array_construct_type(self):
            return self.getTypedRuleContext(QcodeParser.Array_construct_typeContext,0)


        def call_back_construct_type(self):
            return self.getTypedRuleContext(QcodeParser.Call_back_construct_typeContext,0)


        def getRuleIndex(self):
            return QcodeParser.RULE_call_back_primary_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCall_back_primary_type" ):
                listener.enterCall_back_primary_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCall_back_primary_type" ):
                listener.exitCall_back_primary_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCall_back_primary_type" ):
                return visitor.visitCall_back_primary_type(self)
            else:
                return visitor.visitChildren(self)




    def call_back_primary_type(self):

        localctx = QcodeParser.Call_back_primary_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_call_back_primary_type)
        try:
            self.state = 220
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [QcodeParser.INT, QcodeParser.BOOL, QcodeParser.DOUBLE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 215
                self.auxiliary_primary_type()
                pass
            elif token in [QcodeParser.QUBIT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 216
                self.quantum_primary_type()
                pass
            elif token in [QcodeParser.CBIT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 217
                self.classical_primary_type()
                pass
            elif token in [QcodeParser.MAP, QcodeParser.VECTOR]:
                self.enterOuterAlt(localctx, 4)
                self.state = 218
                self.array_construct_type()
                pass
            elif token in [QcodeParser.CIRCUIT]:
                self.enterOuterAlt(localctx, 5)
                self.state = 219
                self.call_back_construct_type()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Declaration_variableContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable_decl_specifier(self):
            return self.getTypedRuleContext(QcodeParser.Variable_decl_specifierContext,0)


        def init_declaratorlist(self):
            return self.getTypedRuleContext(QcodeParser.Init_declaratorlistContext,0)


        def SEMI(self):
            return self.getToken(QcodeParser.SEMI, 0)

        def getRuleIndex(self):
            return QcodeParser.RULE_declaration_variable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclaration_variable" ):
                listener.enterDeclaration_variable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclaration_variable" ):
                listener.exitDeclaration_variable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeclaration_variable" ):
                return visitor.visitDeclaration_variable(self)
            else:
                return visitor.visitChildren(self)




    def declaration_variable(self):

        localctx = QcodeParser.Declaration_variableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_declaration_variable)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 222
            self.variable_decl_specifier()
            self.state = 223
            self.init_declaratorlist(0)
            self.state = 224
            self.match(QcodeParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Variable_decl_specifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def common_specifier(self):
            return self.getTypedRuleContext(QcodeParser.Common_specifierContext,0)


        def array_construct_type(self):
            return self.getTypedRuleContext(QcodeParser.Array_construct_typeContext,0)


        def quantum_circuit_type(self):
            return self.getTypedRuleContext(QcodeParser.Quantum_circuit_typeContext,0)


        def quantum_primary_type(self):
            return self.getTypedRuleContext(QcodeParser.Quantum_primary_typeContext,0)


        def getRuleIndex(self):
            return QcodeParser.RULE_variable_decl_specifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariable_decl_specifier" ):
                listener.enterVariable_decl_specifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariable_decl_specifier" ):
                listener.exitVariable_decl_specifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariable_decl_specifier" ):
                return visitor.visitVariable_decl_specifier(self)
            else:
                return visitor.visitChildren(self)




    def variable_decl_specifier(self):

        localctx = QcodeParser.Variable_decl_specifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_variable_decl_specifier)
        try:
            self.state = 230
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [QcodeParser.LET]:
                self.enterOuterAlt(localctx, 1)
                self.state = 226
                self.common_specifier()
                pass
            elif token in [QcodeParser.MAP, QcodeParser.VECTOR]:
                self.enterOuterAlt(localctx, 2)
                self.state = 227
                self.array_construct_type()
                pass
            elif token in [QcodeParser.CIRCUIT, QcodeParser.VARIATIONALCIRCUIT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 228
                self.quantum_circuit_type()
                pass
            elif token in [QcodeParser.QUBIT]:
                self.enterOuterAlt(localctx, 4)
                self.state = 229
                self.quantum_primary_type()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Common_specifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LET(self):
            return self.getToken(QcodeParser.LET, 0)

        def getRuleIndex(self):
            return QcodeParser.RULE_common_specifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCommon_specifier" ):
                listener.enterCommon_specifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCommon_specifier" ):
                listener.exitCommon_specifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCommon_specifier" ):
                return visitor.visitCommon_specifier(self)
            else:
                return visitor.visitChildren(self)




    def common_specifier(self):

        localctx = QcodeParser.Common_specifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_common_specifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 232
            self.match(QcodeParser.LET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Init_declaratorlistContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable_declarator(self):
            return self.getTypedRuleContext(QcodeParser.Variable_declaratorContext,0)


        def init_declaratorlist(self):
            return self.getTypedRuleContext(QcodeParser.Init_declaratorlistContext,0)


        def COMMA(self):
            return self.getToken(QcodeParser.COMMA, 0)

        def getRuleIndex(self):
            return QcodeParser.RULE_init_declaratorlist

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInit_declaratorlist" ):
                listener.enterInit_declaratorlist(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInit_declaratorlist" ):
                listener.exitInit_declaratorlist(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInit_declaratorlist" ):
                return visitor.visitInit_declaratorlist(self)
            else:
                return visitor.visitChildren(self)



    def init_declaratorlist(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = QcodeParser.Init_declaratorlistContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 44
        self.enterRecursionRule(localctx, 44, self.RULE_init_declaratorlist, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 235
            self.variable_declarator()
            self._ctx.stop = self._input.LT(-1)
            self.state = 242
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,10,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = QcodeParser.Init_declaratorlistContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_init_declaratorlist)
                    self.state = 237
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 238
                    self.match(QcodeParser.COMMA)
                    self.state = 239
                    self.variable_declarator() 
                self.state = 244
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,10,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class Variable_declaratorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(QcodeParser.Identifier, 0)

        def ASSIGN(self):
            return self.getToken(QcodeParser.ASSIGN, 0)

        def variableInitializer(self):
            return self.getTypedRuleContext(QcodeParser.VariableInitializerContext,0)


        def getRuleIndex(self):
            return QcodeParser.RULE_variable_declarator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariable_declarator" ):
                listener.enterVariable_declarator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariable_declarator" ):
                listener.exitVariable_declarator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariable_declarator" ):
                return visitor.visitVariable_declarator(self)
            else:
                return visitor.visitChildren(self)




    def variable_declarator(self):

        localctx = QcodeParser.Variable_declaratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_variable_declarator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 245
            self.match(QcodeParser.Identifier)
            self.state = 248
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                self.state = 246
                self.match(QcodeParser.ASSIGN)
                self.state = 247
                self.variableInitializer(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VariableInitializerContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def single_expression(self):
            return self.getTypedRuleContext(QcodeParser.Single_expressionContext,0)


        def variableInitializer(self):
            return self.getTypedRuleContext(QcodeParser.VariableInitializerContext,0)


        def COMMA(self):
            return self.getToken(QcodeParser.COMMA, 0)

        def getRuleIndex(self):
            return QcodeParser.RULE_variableInitializer

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableInitializer" ):
                listener.enterVariableInitializer(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableInitializer" ):
                listener.exitVariableInitializer(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableInitializer" ):
                return visitor.visitVariableInitializer(self)
            else:
                return visitor.visitChildren(self)



    def variableInitializer(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = QcodeParser.VariableInitializerContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 48
        self.enterRecursionRule(localctx, 48, self.RULE_variableInitializer, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 251
            self.single_expression(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 258
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,12,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = QcodeParser.VariableInitializerContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_variableInitializer)
                    self.state = 253
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 254
                    self.match(QcodeParser.COMMA)
                    self.state = 255
                    self.single_expression(0) 
                self.state = 260
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,12,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class Function_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def declarate_function(self):
            return self.getTypedRuleContext(QcodeParser.Declarate_functionContext,0)


        def SEMI(self):
            return self.getToken(QcodeParser.SEMI, 0)

        def getRuleIndex(self):
            return QcodeParser.RULE_function_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_declaration" ):
                listener.enterFunction_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_declaration" ):
                listener.exitFunction_declaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunction_declaration" ):
                return visitor.visitFunction_declaration(self)
            else:
                return visitor.visitChildren(self)




    def function_declaration(self):

        localctx = QcodeParser.Function_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_function_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 261
            self.declarate_function()
            self.state = 262
            self.match(QcodeParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Declarate_functionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def function_declarator(self):
            return self.getTypedRuleContext(QcodeParser.Function_declaratorContext,0)


        def function_return_type_declarator(self):
            return self.getTypedRuleContext(QcodeParser.Function_return_type_declaratorContext,0)


        def getRuleIndex(self):
            return QcodeParser.RULE_declarate_function

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclarate_function" ):
                listener.enterDeclarate_function(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclarate_function" ):
                listener.exitDeclarate_function(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeclarate_function" ):
                return visitor.visitDeclarate_function(self)
            else:
                return visitor.visitChildren(self)




    def declarate_function(self):

        localctx = QcodeParser.Declarate_functionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_declarate_function)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 265
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << QcodeParser.INT) | (1 << QcodeParser.BOOL) | (1 << QcodeParser.DOUBLE) | (1 << QcodeParser.MAP) | (1 << QcodeParser.VECTOR) | (1 << QcodeParser.CBIT) | (1 << QcodeParser.CIRCUIT) | (1 << QcodeParser.QPROG) | (1 << QcodeParser.VARIATIONALCIRCUIT))) != 0):
                self.state = 264
                self.function_return_type_declarator()


            self.state = 267
            self.function_declarator()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Function_return_type_declaratorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def quantum_prog_type(self):
            return self.getTypedRuleContext(QcodeParser.Quantum_prog_typeContext,0)


        def quantum_circuit_type(self):
            return self.getTypedRuleContext(QcodeParser.Quantum_circuit_typeContext,0)


        def auxiliary_primary_type(self):
            return self.getTypedRuleContext(QcodeParser.Auxiliary_primary_typeContext,0)


        def classical_primary_type(self):
            return self.getTypedRuleContext(QcodeParser.Classical_primary_typeContext,0)


        def array_construct_type(self):
            return self.getTypedRuleContext(QcodeParser.Array_construct_typeContext,0)


        def call_back_construct_type(self):
            return self.getTypedRuleContext(QcodeParser.Call_back_construct_typeContext,0)


        def getRuleIndex(self):
            return QcodeParser.RULE_function_return_type_declarator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_return_type_declarator" ):
                listener.enterFunction_return_type_declarator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_return_type_declarator" ):
                listener.exitFunction_return_type_declarator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunction_return_type_declarator" ):
                return visitor.visitFunction_return_type_declarator(self)
            else:
                return visitor.visitChildren(self)




    def function_return_type_declarator(self):

        localctx = QcodeParser.Function_return_type_declaratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_function_return_type_declarator)
        try:
            self.state = 275
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 269
                self.quantum_prog_type()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 270
                self.quantum_circuit_type()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 271
                self.auxiliary_primary_type()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 272
                self.classical_primary_type()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 273
                self.array_construct_type()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 274
                self.call_back_construct_type()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Function_declaratorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def function_name(self):
            return self.getTypedRuleContext(QcodeParser.Function_nameContext,0)


        def LPAREN(self):
            return self.getToken(QcodeParser.LPAREN, 0)

        def parameter_decl_list(self):
            return self.getTypedRuleContext(QcodeParser.Parameter_decl_listContext,0)


        def RPAREN(self):
            return self.getToken(QcodeParser.RPAREN, 0)

        def getRuleIndex(self):
            return QcodeParser.RULE_function_declarator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_declarator" ):
                listener.enterFunction_declarator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_declarator" ):
                listener.exitFunction_declarator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunction_declarator" ):
                return visitor.visitFunction_declarator(self)
            else:
                return visitor.visitChildren(self)




    def function_declarator(self):

        localctx = QcodeParser.Function_declaratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_function_declarator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 277
            self.function_name()
            self.state = 278
            self.match(QcodeParser.LPAREN)
            self.state = 279
            self.parameter_decl_list(0)
            self.state = 280
            self.match(QcodeParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Function_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(QcodeParser.Identifier, 0)

        def getRuleIndex(self):
            return QcodeParser.RULE_function_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_name" ):
                listener.enterFunction_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_name" ):
                listener.exitFunction_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunction_name" ):
                return visitor.visitFunction_name(self)
            else:
                return visitor.visitChildren(self)




    def function_name(self):

        localctx = QcodeParser.Function_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_function_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 282
            self.match(QcodeParser.Identifier)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Parameter_decl_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def parameter_declaration(self):
            return self.getTypedRuleContext(QcodeParser.Parameter_declarationContext,0)


        def parameter_decl_list(self):
            return self.getTypedRuleContext(QcodeParser.Parameter_decl_listContext,0)


        def COMMA(self):
            return self.getToken(QcodeParser.COMMA, 0)

        def getRuleIndex(self):
            return QcodeParser.RULE_parameter_decl_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameter_decl_list" ):
                listener.enterParameter_decl_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameter_decl_list" ):
                listener.exitParameter_decl_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameter_decl_list" ):
                return visitor.visitParameter_decl_list(self)
            else:
                return visitor.visitChildren(self)



    def parameter_decl_list(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = QcodeParser.Parameter_decl_listContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 60
        self.enterRecursionRule(localctx, 60, self.RULE_parameter_decl_list, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 285
            self.parameter_declaration()
            self._ctx.stop = self._input.LT(-1)
            self.state = 292
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,15,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = QcodeParser.Parameter_decl_listContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_parameter_decl_list)
                    self.state = 287
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 288
                    self.match(QcodeParser.COMMA)
                    self.state = 289
                    self.parameter_declaration() 
                self.state = 294
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,15,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class Expression_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.exp_list_alias = None # Expression_listContext

        def single_expression(self):
            return self.getTypedRuleContext(QcodeParser.Single_expressionContext,0)


        def COMMA(self):
            return self.getToken(QcodeParser.COMMA, 0)

        def expression_list(self):
            return self.getTypedRuleContext(QcodeParser.Expression_listContext,0)


        def getRuleIndex(self):
            return QcodeParser.RULE_expression_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression_list" ):
                listener.enterExpression_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression_list" ):
                listener.exitExpression_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpression_list" ):
                return visitor.visitExpression_list(self)
            else:
                return visitor.visitChildren(self)



    def expression_list(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = QcodeParser.Expression_listContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 62
        self.enterRecursionRule(localctx, 62, self.RULE_expression_list, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 296
            self.single_expression(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 303
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,16,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = QcodeParser.Expression_listContext(self, _parentctx, _parentState)
                    localctx.exp_list_alias = _prevctx
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_expression_list)
                    self.state = 298
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 299
                    self.match(QcodeParser.COMMA)
                    self.state = 300
                    self.single_expression(0) 
                self.state = 305
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,16,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class Vector_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def single_expression(self):
            return self.getTypedRuleContext(QcodeParser.Single_expressionContext,0)


        def vector_slice(self):
            return self.getTypedRuleContext(QcodeParser.Vector_sliceContext,0)


        def getRuleIndex(self):
            return QcodeParser.RULE_vector_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVector_expression" ):
                listener.enterVector_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVector_expression" ):
                listener.exitVector_expression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVector_expression" ):
                return visitor.visitVector_expression(self)
            else:
                return visitor.visitChildren(self)




    def vector_expression(self):

        localctx = QcodeParser.Vector_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_vector_expression)
        try:
            self.state = 308
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 306
                self.single_expression(0)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 307
                self.vector_slice()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Vector_sliceContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.vector_bound_alias_l = None # Single_expressionContext
            self.vector_bound_alias_r = None # Single_expressionContext

        def COLON(self):
            return self.getToken(QcodeParser.COLON, 0)

        def single_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QcodeParser.Single_expressionContext)
            else:
                return self.getTypedRuleContext(QcodeParser.Single_expressionContext,i)


        def getRuleIndex(self):
            return QcodeParser.RULE_vector_slice

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVector_slice" ):
                listener.enterVector_slice(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVector_slice" ):
                listener.exitVector_slice(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVector_slice" ):
                return visitor.visitVector_slice(self)
            else:
                return visitor.visitChildren(self)




    def vector_slice(self):

        localctx = QcodeParser.Vector_sliceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_vector_slice)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 310
            localctx.vector_bound_alias_l = self.single_expression(0)
            self.state = 311
            self.match(QcodeParser.COLON)
            self.state = 312
            localctx.vector_bound_alias_r = self.single_expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Single_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.get_index_exp = None # Single_expressionContext
            self.get_inside_exp = None # Single_expressionContext
            self.function_call_exp = None # Single_expressionContext
            self.postfix_add_exp = None # Single_expressionContext
            self.postfix_dec_exp = None # Single_expressionContext
            self.binary_mul_left_exp = None # Single_expressionContext
            self.binary_add_left_exp = None # Single_expressionContext
            self.shift_exp_left_exp = None # Single_expressionContext
            self.relationship_left_exp = None # Single_expressionContext
            self.equal_left_exp = None # Single_expressionContext
            self.logic_left_exp = None # Single_expressionContext
            self.triple_exp_condition = None # Single_expressionContext
            self.assign_exp_left = None # Single_expressionContext
            self.bracket_exp = None # Expression_listContext
            self.parenthesis_exp = None # Expression_listContext
            self.unary_exp = None # Single_expressionContext
            self.get_inside_bee_exp = None # Single_expressionContext
            self.binary_mul_right_exp = None # Single_expressionContext
            self.binary_add_right_exp = None # Single_expressionContext
            self.shift_exp_right_exp = None # Single_expressionContext
            self.relationship_right_exp = None # Single_expressionContext
            self.equal_right_exp = None # Single_expressionContext
            self.logic_right_exp = None # Single_expressionContext
            self.triple_exp_true = None # Single_expressionContext
            self.triple_exp_false = None # Single_expressionContext
            self.assign_exp_right = None # Single_expressionContext

        def LBRACK(self):
            return self.getToken(QcodeParser.LBRACK, 0)

        def RBRACK(self):
            return self.getToken(QcodeParser.RBRACK, 0)

        def expression_list(self):
            return self.getTypedRuleContext(QcodeParser.Expression_listContext,0)


        def LPAREN(self):
            return self.getToken(QcodeParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(QcodeParser.RPAREN, 0)

        def unary_op(self):
            return self.getTypedRuleContext(QcodeParser.Unary_opContext,0)


        def single_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QcodeParser.Single_expressionContext)
            else:
                return self.getTypedRuleContext(QcodeParser.Single_expressionContext,i)


        def lambda_exp(self):
            return self.getTypedRuleContext(QcodeParser.Lambda_expContext,0)


        def Identifier(self):
            return self.getToken(QcodeParser.Identifier, 0)

        def constant(self):
            return self.getTypedRuleContext(QcodeParser.ConstantContext,0)


        def key_words(self):
            return self.getTypedRuleContext(QcodeParser.Key_wordsContext,0)


        def PI(self):
            return self.getToken(QcodeParser.PI, 0)

        def DOT(self):
            return self.getToken(QcodeParser.DOT, 0)

        def multiplicative_op(self):
            return self.getTypedRuleContext(QcodeParser.Multiplicative_opContext,0)


        def additive_op(self):
            return self.getTypedRuleContext(QcodeParser.Additive_opContext,0)


        def shift_op(self):
            return self.getTypedRuleContext(QcodeParser.Shift_opContext,0)


        def relationship_op(self):
            return self.getTypedRuleContext(QcodeParser.Relationship_opContext,0)


        def equal_op(self):
            return self.getTypedRuleContext(QcodeParser.Equal_opContext,0)


        def logic_op(self):
            return self.getTypedRuleContext(QcodeParser.Logic_opContext,0)


        def QUE_MARK(self):
            return self.getToken(QcodeParser.QUE_MARK, 0)

        def COLON(self):
            return self.getToken(QcodeParser.COLON, 0)

        def assign_op(self):
            return self.getTypedRuleContext(QcodeParser.Assign_opContext,0)


        def vector_expression(self):
            return self.getTypedRuleContext(QcodeParser.Vector_expressionContext,0)


        def INC(self):
            return self.getToken(QcodeParser.INC, 0)

        def DEC(self):
            return self.getToken(QcodeParser.DEC, 0)

        def getRuleIndex(self):
            return QcodeParser.RULE_single_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSingle_expression" ):
                listener.enterSingle_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSingle_expression" ):
                listener.exitSingle_expression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSingle_expression" ):
                return visitor.visitSingle_expression(self)
            else:
                return visitor.visitChildren(self)



    def single_expression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = QcodeParser.Single_expressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 68
        self.enterRecursionRule(localctx, 68, self.RULE_single_expression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 333
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,20,self._ctx)
            if la_ == 1:
                self.state = 315
                self.match(QcodeParser.LBRACK)
                self.state = 317
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << QcodeParser.LET) | (1 << QcodeParser.INCLUDE) | (1 << QcodeParser.INT) | (1 << QcodeParser.BOOL) | (1 << QcodeParser.IF) | (1 << QcodeParser.ELSE) | (1 << QcodeParser.FOR) | (1 << QcodeParser.LIB) | (1 << QcodeParser.QRUNES) | (1 << QcodeParser.AVAR) | (1 << QcodeParser.DOUBLE) | (1 << QcodeParser.IN) | (1 << QcodeParser.PI) | (1 << QcodeParser.RETURN) | (1 << QcodeParser.LAMBDA) | (1 << QcodeParser.BREAK) | (1 << QcodeParser.CONTINUE) | (1 << QcodeParser.TRUE) | (1 << QcodeParser.FALSE) | (1 << QcodeParser.QUBIT) | (1 << QcodeParser.CBIT) | (1 << QcodeParser.VQG_CNOT_VCGEN) | (1 << QcodeParser.VQG_RZ_VCGEN) | (1 << QcodeParser.VQG_RX_VCGEN) | (1 << QcodeParser.H_GATE) | (1 << QcodeParser.X_GATE) | (1 << QcodeParser.NOT_GATE) | (1 << QcodeParser.T_GATE) | (1 << QcodeParser.S_GATE) | (1 << QcodeParser.Y_GATE) | (1 << QcodeParser.Z_GATE) | (1 << QcodeParser.X1_GATE) | (1 << QcodeParser.Y1_GATE) | (1 << QcodeParser.Z1_GATE) | (1 << QcodeParser.U4_GATE) | (1 << QcodeParser.RX_GATE) | (1 << QcodeParser.RY_GATE) | (1 << QcodeParser.RZ_GATE) | (1 << QcodeParser.TOFFOLI_GATE) | (1 << QcodeParser.CNOT_GATE) | (1 << QcodeParser.CZ_GATE) | (1 << QcodeParser.CR_GATE) | (1 << QcodeParser.CU_GATE) | (1 << QcodeParser.ISWAP) | (1 << QcodeParser.APPLY_QGATE) | (1 << QcodeParser.MEASURE) | (1 << QcodeParser.MEASUREALL) | (1 << QcodeParser.QIF) | (1 << QcodeParser.QWHILE) | (1 << QcodeParser.QELSE))) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (QcodeParser.BANG - 65)) | (1 << (QcodeParser.TILDE - 65)) | (1 << (QcodeParser.INC - 65)) | (1 << (QcodeParser.DEC - 65)) | (1 << (QcodeParser.SUB - 65)) | (1 << (QcodeParser.LPAREN - 65)) | (1 << (QcodeParser.LBRACK - 65)) | (1 << (QcodeParser.Identifier - 65)) | (1 << (QcodeParser.Integer_Literal - 65)) | (1 << (QcodeParser.Double_Literal - 65)))) != 0):
                    self.state = 316
                    localctx.bracket_exp = self.expression_list(0)


                self.state = 319
                self.match(QcodeParser.RBRACK)
                pass

            elif la_ == 2:
                self.state = 320
                self.match(QcodeParser.LPAREN)
                self.state = 322
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << QcodeParser.LET) | (1 << QcodeParser.INCLUDE) | (1 << QcodeParser.INT) | (1 << QcodeParser.BOOL) | (1 << QcodeParser.IF) | (1 << QcodeParser.ELSE) | (1 << QcodeParser.FOR) | (1 << QcodeParser.LIB) | (1 << QcodeParser.QRUNES) | (1 << QcodeParser.AVAR) | (1 << QcodeParser.DOUBLE) | (1 << QcodeParser.IN) | (1 << QcodeParser.PI) | (1 << QcodeParser.RETURN) | (1 << QcodeParser.LAMBDA) | (1 << QcodeParser.BREAK) | (1 << QcodeParser.CONTINUE) | (1 << QcodeParser.TRUE) | (1 << QcodeParser.FALSE) | (1 << QcodeParser.QUBIT) | (1 << QcodeParser.CBIT) | (1 << QcodeParser.VQG_CNOT_VCGEN) | (1 << QcodeParser.VQG_RZ_VCGEN) | (1 << QcodeParser.VQG_RX_VCGEN) | (1 << QcodeParser.H_GATE) | (1 << QcodeParser.X_GATE) | (1 << QcodeParser.NOT_GATE) | (1 << QcodeParser.T_GATE) | (1 << QcodeParser.S_GATE) | (1 << QcodeParser.Y_GATE) | (1 << QcodeParser.Z_GATE) | (1 << QcodeParser.X1_GATE) | (1 << QcodeParser.Y1_GATE) | (1 << QcodeParser.Z1_GATE) | (1 << QcodeParser.U4_GATE) | (1 << QcodeParser.RX_GATE) | (1 << QcodeParser.RY_GATE) | (1 << QcodeParser.RZ_GATE) | (1 << QcodeParser.TOFFOLI_GATE) | (1 << QcodeParser.CNOT_GATE) | (1 << QcodeParser.CZ_GATE) | (1 << QcodeParser.CR_GATE) | (1 << QcodeParser.CU_GATE) | (1 << QcodeParser.ISWAP) | (1 << QcodeParser.APPLY_QGATE) | (1 << QcodeParser.MEASURE) | (1 << QcodeParser.MEASUREALL) | (1 << QcodeParser.QIF) | (1 << QcodeParser.QWHILE) | (1 << QcodeParser.QELSE))) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (QcodeParser.BANG - 65)) | (1 << (QcodeParser.TILDE - 65)) | (1 << (QcodeParser.INC - 65)) | (1 << (QcodeParser.DEC - 65)) | (1 << (QcodeParser.SUB - 65)) | (1 << (QcodeParser.LPAREN - 65)) | (1 << (QcodeParser.LBRACK - 65)) | (1 << (QcodeParser.Identifier - 65)) | (1 << (QcodeParser.Integer_Literal - 65)) | (1 << (QcodeParser.Double_Literal - 65)))) != 0):
                    self.state = 321
                    localctx.parenthesis_exp = self.expression_list(0)


                self.state = 324
                self.match(QcodeParser.RPAREN)
                pass

            elif la_ == 3:
                self.state = 325
                self.unary_op()
                self.state = 326
                localctx.unary_exp = self.single_expression(14)
                pass

            elif la_ == 4:
                self.state = 328
                self.lambda_exp()
                pass

            elif la_ == 5:
                self.state = 329
                self.match(QcodeParser.Identifier)
                pass

            elif la_ == 6:
                self.state = 330
                self.constant()
                pass

            elif la_ == 7:
                self.state = 331
                self.key_words()
                pass

            elif la_ == 8:
                self.state = 332
                self.match(QcodeParser.PI)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 389
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,23,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 387
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
                    if la_ == 1:
                        localctx = QcodeParser.Single_expressionContext(self, _parentctx, _parentState)
                        localctx.get_inside_exp = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_single_expression)
                        self.state = 335
                        if not self.precpred(self._ctx, 18):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 18)")
                        self.state = 336
                        self.match(QcodeParser.DOT)
                        self.state = 337
                        localctx.get_inside_bee_exp = self.single_expression(19)
                        pass

                    elif la_ == 2:
                        localctx = QcodeParser.Single_expressionContext(self, _parentctx, _parentState)
                        localctx.binary_mul_left_exp = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_single_expression)
                        self.state = 338
                        if not self.precpred(self._ctx, 13):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 13)")
                        self.state = 339
                        self.multiplicative_op()
                        self.state = 340
                        localctx.binary_mul_right_exp = self.single_expression(14)
                        pass

                    elif la_ == 3:
                        localctx = QcodeParser.Single_expressionContext(self, _parentctx, _parentState)
                        localctx.binary_add_left_exp = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_single_expression)
                        self.state = 342
                        if not self.precpred(self._ctx, 12):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 12)")
                        self.state = 343
                        self.additive_op()
                        self.state = 344
                        localctx.binary_add_right_exp = self.single_expression(13)
                        pass

                    elif la_ == 4:
                        localctx = QcodeParser.Single_expressionContext(self, _parentctx, _parentState)
                        localctx.shift_exp_left_exp = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_single_expression)
                        self.state = 346
                        if not self.precpred(self._ctx, 11):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 11)")
                        self.state = 347
                        self.shift_op()
                        self.state = 348
                        localctx.shift_exp_right_exp = self.single_expression(12)
                        pass

                    elif la_ == 5:
                        localctx = QcodeParser.Single_expressionContext(self, _parentctx, _parentState)
                        localctx.relationship_left_exp = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_single_expression)
                        self.state = 350
                        if not self.precpred(self._ctx, 10):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 10)")
                        self.state = 351
                        self.relationship_op()
                        self.state = 352
                        localctx.relationship_right_exp = self.single_expression(11)
                        pass

                    elif la_ == 6:
                        localctx = QcodeParser.Single_expressionContext(self, _parentctx, _parentState)
                        localctx.equal_left_exp = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_single_expression)
                        self.state = 354
                        if not self.precpred(self._ctx, 9):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 9)")
                        self.state = 355
                        self.equal_op()
                        self.state = 356
                        localctx.equal_right_exp = self.single_expression(10)
                        pass

                    elif la_ == 7:
                        localctx = QcodeParser.Single_expressionContext(self, _parentctx, _parentState)
                        localctx.logic_left_exp = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_single_expression)
                        self.state = 358
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
                        self.state = 359
                        self.logic_op()
                        self.state = 360
                        localctx.logic_right_exp = self.single_expression(9)
                        pass

                    elif la_ == 8:
                        localctx = QcodeParser.Single_expressionContext(self, _parentctx, _parentState)
                        localctx.triple_exp_condition = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_single_expression)
                        self.state = 362
                        if not self.precpred(self._ctx, 7):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
                        self.state = 363
                        self.match(QcodeParser.QUE_MARK)
                        self.state = 364
                        localctx.triple_exp_true = self.single_expression(0)
                        self.state = 365
                        self.match(QcodeParser.COLON)
                        self.state = 366
                        localctx.triple_exp_false = self.single_expression(8)
                        pass

                    elif la_ == 9:
                        localctx = QcodeParser.Single_expressionContext(self, _parentctx, _parentState)
                        localctx.assign_exp_left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_single_expression)
                        self.state = 368
                        if not self.precpred(self._ctx, 6):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                        self.state = 369
                        self.assign_op()
                        self.state = 370
                        localctx.assign_exp_right = self.single_expression(7)
                        pass

                    elif la_ == 10:
                        localctx = QcodeParser.Single_expressionContext(self, _parentctx, _parentState)
                        localctx.get_index_exp = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_single_expression)
                        self.state = 372
                        if not self.precpred(self._ctx, 19):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 19)")
                        self.state = 373
                        self.match(QcodeParser.LBRACK)
                        self.state = 374
                        self.vector_expression()
                        self.state = 375
                        self.match(QcodeParser.RBRACK)
                        pass

                    elif la_ == 11:
                        localctx = QcodeParser.Single_expressionContext(self, _parentctx, _parentState)
                        localctx.function_call_exp = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_single_expression)
                        self.state = 377
                        if not self.precpred(self._ctx, 17):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 17)")
                        self.state = 378
                        self.match(QcodeParser.LPAREN)
                        self.state = 380
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << QcodeParser.LET) | (1 << QcodeParser.INCLUDE) | (1 << QcodeParser.INT) | (1 << QcodeParser.BOOL) | (1 << QcodeParser.IF) | (1 << QcodeParser.ELSE) | (1 << QcodeParser.FOR) | (1 << QcodeParser.LIB) | (1 << QcodeParser.QRUNES) | (1 << QcodeParser.AVAR) | (1 << QcodeParser.DOUBLE) | (1 << QcodeParser.IN) | (1 << QcodeParser.PI) | (1 << QcodeParser.RETURN) | (1 << QcodeParser.LAMBDA) | (1 << QcodeParser.BREAK) | (1 << QcodeParser.CONTINUE) | (1 << QcodeParser.TRUE) | (1 << QcodeParser.FALSE) | (1 << QcodeParser.QUBIT) | (1 << QcodeParser.CBIT) | (1 << QcodeParser.VQG_CNOT_VCGEN) | (1 << QcodeParser.VQG_RZ_VCGEN) | (1 << QcodeParser.VQG_RX_VCGEN) | (1 << QcodeParser.H_GATE) | (1 << QcodeParser.X_GATE) | (1 << QcodeParser.NOT_GATE) | (1 << QcodeParser.T_GATE) | (1 << QcodeParser.S_GATE) | (1 << QcodeParser.Y_GATE) | (1 << QcodeParser.Z_GATE) | (1 << QcodeParser.X1_GATE) | (1 << QcodeParser.Y1_GATE) | (1 << QcodeParser.Z1_GATE) | (1 << QcodeParser.U4_GATE) | (1 << QcodeParser.RX_GATE) | (1 << QcodeParser.RY_GATE) | (1 << QcodeParser.RZ_GATE) | (1 << QcodeParser.TOFFOLI_GATE) | (1 << QcodeParser.CNOT_GATE) | (1 << QcodeParser.CZ_GATE) | (1 << QcodeParser.CR_GATE) | (1 << QcodeParser.CU_GATE) | (1 << QcodeParser.ISWAP) | (1 << QcodeParser.APPLY_QGATE) | (1 << QcodeParser.MEASURE) | (1 << QcodeParser.MEASUREALL) | (1 << QcodeParser.QIF) | (1 << QcodeParser.QWHILE) | (1 << QcodeParser.QELSE))) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (QcodeParser.BANG - 65)) | (1 << (QcodeParser.TILDE - 65)) | (1 << (QcodeParser.INC - 65)) | (1 << (QcodeParser.DEC - 65)) | (1 << (QcodeParser.SUB - 65)) | (1 << (QcodeParser.LPAREN - 65)) | (1 << (QcodeParser.LBRACK - 65)) | (1 << (QcodeParser.Identifier - 65)) | (1 << (QcodeParser.Integer_Literal - 65)) | (1 << (QcodeParser.Double_Literal - 65)))) != 0):
                            self.state = 379
                            self.expression_list(0)


                        self.state = 382
                        self.match(QcodeParser.RPAREN)
                        pass

                    elif la_ == 12:
                        localctx = QcodeParser.Single_expressionContext(self, _parentctx, _parentState)
                        localctx.postfix_add_exp = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_single_expression)
                        self.state = 383
                        if not self.precpred(self._ctx, 16):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 16)")
                        self.state = 384
                        self.match(QcodeParser.INC)
                        pass

                    elif la_ == 13:
                        localctx = QcodeParser.Single_expressionContext(self, _parentctx, _parentState)
                        localctx.postfix_dec_exp = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_single_expression)
                        self.state = 385
                        if not self.precpred(self._ctx, 15):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 15)")
                        self.state = 386
                        self.match(QcodeParser.DEC)
                        pass

             
                self.state = 391
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,23,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class Lambda_expContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LAMBDA(self):
            return self.getToken(QcodeParser.LAMBDA, 0)

        def LPAREN(self):
            return self.getToken(QcodeParser.LPAREN, 0)

        def parameter_decl_list(self):
            return self.getTypedRuleContext(QcodeParser.Parameter_decl_listContext,0)


        def RPAREN(self):
            return self.getToken(QcodeParser.RPAREN, 0)

        def COLON(self):
            return self.getToken(QcodeParser.COLON, 0)

        def lambda_body(self):
            return self.getTypedRuleContext(QcodeParser.Lambda_bodyContext,0)


        def getRuleIndex(self):
            return QcodeParser.RULE_lambda_exp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLambda_exp" ):
                listener.enterLambda_exp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLambda_exp" ):
                listener.exitLambda_exp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLambda_exp" ):
                return visitor.visitLambda_exp(self)
            else:
                return visitor.visitChildren(self)




    def lambda_exp(self):

        localctx = QcodeParser.Lambda_expContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_lambda_exp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 392
            self.match(QcodeParser.LAMBDA)
            self.state = 393
            self.match(QcodeParser.LPAREN)
            self.state = 394
            self.parameter_decl_list(0)
            self.state = 395
            self.match(QcodeParser.RPAREN)
            self.state = 396
            self.match(QcodeParser.COLON)
            self.state = 397
            self.lambda_body()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Lambda_bodyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def compound_statement(self):
            return self.getTypedRuleContext(QcodeParser.Compound_statementContext,0)


        def getRuleIndex(self):
            return QcodeParser.RULE_lambda_body

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLambda_body" ):
                listener.enterLambda_body(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLambda_body" ):
                listener.exitLambda_body(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLambda_body" ):
                return visitor.visitLambda_body(self)
            else:
                return visitor.visitChildren(self)




    def lambda_body(self):

        localctx = QcodeParser.Lambda_bodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_lambda_body)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 399
            self.compound_statement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Additive_opContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SUB(self):
            return self.getToken(QcodeParser.SUB, 0)

        def ADD(self):
            return self.getToken(QcodeParser.ADD, 0)

        def getRuleIndex(self):
            return QcodeParser.RULE_additive_op

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdditive_op" ):
                listener.enterAdditive_op(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdditive_op" ):
                listener.exitAdditive_op(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAdditive_op" ):
                return visitor.visitAdditive_op(self)
            else:
                return visitor.visitChildren(self)




    def additive_op(self):

        localctx = QcodeParser.Additive_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_additive_op)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 401
            _la = self._input.LA(1)
            if not(_la==QcodeParser.ADD or _la==QcodeParser.SUB):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Multiplicative_opContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MUL(self):
            return self.getToken(QcodeParser.MUL, 0)

        def DIV(self):
            return self.getToken(QcodeParser.DIV, 0)

        def MOD(self):
            return self.getToken(QcodeParser.MOD, 0)

        def getRuleIndex(self):
            return QcodeParser.RULE_multiplicative_op

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiplicative_op" ):
                listener.enterMultiplicative_op(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiplicative_op" ):
                listener.exitMultiplicative_op(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiplicative_op" ):
                return visitor.visitMultiplicative_op(self)
            else:
                return visitor.visitChildren(self)




    def multiplicative_op(self):

        localctx = QcodeParser.Multiplicative_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_multiplicative_op)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 403
            _la = self._input.LA(1)
            if not(((((_la - 82)) & ~0x3f) == 0 and ((1 << (_la - 82)) & ((1 << (QcodeParser.MUL - 82)) | (1 << (QcodeParser.DIV - 82)) | (1 << (QcodeParser.MOD - 82)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Shift_opContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHIFT_LEFT(self):
            return self.getToken(QcodeParser.SHIFT_LEFT, 0)

        def SHIFT_RIGHT(self):
            return self.getToken(QcodeParser.SHIFT_RIGHT, 0)

        def getRuleIndex(self):
            return QcodeParser.RULE_shift_op

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShift_op" ):
                listener.enterShift_op(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShift_op" ):
                listener.exitShift_op(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShift_op" ):
                return visitor.visitShift_op(self)
            else:
                return visitor.visitChildren(self)




    def shift_op(self):

        localctx = QcodeParser.Shift_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_shift_op)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 405
            _la = self._input.LA(1)
            if not(_la==QcodeParser.SHIFT_LEFT or _la==QcodeParser.SHIFT_RIGHT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Assign_opContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASSIGN(self):
            return self.getToken(QcodeParser.ASSIGN, 0)

        def ADD_ASSIGN(self):
            return self.getToken(QcodeParser.ADD_ASSIGN, 0)

        def SUB_ASSIGN(self):
            return self.getToken(QcodeParser.SUB_ASSIGN, 0)

        def MUL_ASSIGN(self):
            return self.getToken(QcodeParser.MUL_ASSIGN, 0)

        def DIV_ASSIGN(self):
            return self.getToken(QcodeParser.DIV_ASSIGN, 0)

        def MOD_ASSIGN(self):
            return self.getToken(QcodeParser.MOD_ASSIGN, 0)

        def getRuleIndex(self):
            return QcodeParser.RULE_assign_op

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_op" ):
                listener.enterAssign_op(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_op" ):
                listener.exitAssign_op(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssign_op" ):
                return visitor.visitAssign_op(self)
            else:
                return visitor.visitChildren(self)




    def assign_op(self):

        localctx = QcodeParser.Assign_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_assign_op)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 407
            _la = self._input.LA(1)
            if not(((((_la - 62)) & ~0x3f) == 0 and ((1 << (_la - 62)) & ((1 << (QcodeParser.ASSIGN - 62)) | (1 << (QcodeParser.ADD_ASSIGN - 62)) | (1 << (QcodeParser.SUB_ASSIGN - 62)) | (1 << (QcodeParser.MUL_ASSIGN - 62)) | (1 << (QcodeParser.DIV_ASSIGN - 62)) | (1 << (QcodeParser.MOD_ASSIGN - 62)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Equal_opContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQUAL(self):
            return self.getToken(QcodeParser.EQUAL, 0)

        def NOTEQUAL(self):
            return self.getToken(QcodeParser.NOTEQUAL, 0)

        def getRuleIndex(self):
            return QcodeParser.RULE_equal_op

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEqual_op" ):
                listener.enterEqual_op(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEqual_op" ):
                listener.exitEqual_op(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEqual_op" ):
                return visitor.visitEqual_op(self)
            else:
                return visitor.visitChildren(self)




    def equal_op(self):

        localctx = QcodeParser.Equal_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_equal_op)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 409
            _la = self._input.LA(1)
            if not(_la==QcodeParser.EQUAL or _la==QcodeParser.NOTEQUAL):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Relationship_opContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LT(self):
            return self.getToken(QcodeParser.LT, 0)

        def LE(self):
            return self.getToken(QcodeParser.LE, 0)

        def GT(self):
            return self.getToken(QcodeParser.GT, 0)

        def GE(self):
            return self.getToken(QcodeParser.GE, 0)

        def getRuleIndex(self):
            return QcodeParser.RULE_relationship_op

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelationship_op" ):
                listener.enterRelationship_op(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelationship_op" ):
                listener.exitRelationship_op(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRelationship_op" ):
                return visitor.visitRelationship_op(self)
            else:
                return visitor.visitChildren(self)




    def relationship_op(self):

        localctx = QcodeParser.Relationship_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_relationship_op)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 411
            _la = self._input.LA(1)
            if not(((((_la - 63)) & ~0x3f) == 0 and ((1 << (_la - 63)) & ((1 << (QcodeParser.GT - 63)) | (1 << (QcodeParser.LT - 63)) | (1 << (QcodeParser.LE - 63)) | (1 << (QcodeParser.GE - 63)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Logic_opContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LOGIC_AND(self):
            return self.getToken(QcodeParser.LOGIC_AND, 0)

        def LOGIC_OR(self):
            return self.getToken(QcodeParser.LOGIC_OR, 0)

        def getRuleIndex(self):
            return QcodeParser.RULE_logic_op

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogic_op" ):
                listener.enterLogic_op(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogic_op" ):
                listener.exitLogic_op(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogic_op" ):
                return visitor.visitLogic_op(self)
            else:
                return visitor.visitChildren(self)




    def logic_op(self):

        localctx = QcodeParser.Logic_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_logic_op)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 413
            _la = self._input.LA(1)
            if not(_la==QcodeParser.LOGIC_AND or _la==QcodeParser.LOGIC_OR):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Unary_opContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TILDE(self):
            return self.getToken(QcodeParser.TILDE, 0)

        def BANG(self):
            return self.getToken(QcodeParser.BANG, 0)

        def INC(self):
            return self.getToken(QcodeParser.INC, 0)

        def DEC(self):
            return self.getToken(QcodeParser.DEC, 0)

        def SUB(self):
            return self.getToken(QcodeParser.SUB, 0)

        def getRuleIndex(self):
            return QcodeParser.RULE_unary_op

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnary_op" ):
                listener.enterUnary_op(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnary_op" ):
                listener.exitUnary_op(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnary_op" ):
                return visitor.visitUnary_op(self)
            else:
                return visitor.visitChildren(self)




    def unary_op(self):

        localctx = QcodeParser.Unary_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_unary_op)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 415
            _la = self._input.LA(1)
            if not(((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (QcodeParser.BANG - 65)) | (1 << (QcodeParser.TILDE - 65)) | (1 << (QcodeParser.INC - 65)) | (1 << (QcodeParser.DEC - 65)) | (1 << (QcodeParser.SUB - 65)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StatementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression_statement(self):
            return self.getTypedRuleContext(QcodeParser.Expression_statementContext,0)


        def empty_statement(self):
            return self.getTypedRuleContext(QcodeParser.Empty_statementContext,0)


        def declaration_variable_statement(self):
            return self.getTypedRuleContext(QcodeParser.Declaration_variable_statementContext,0)


        def compound_statement(self):
            return self.getTypedRuleContext(QcodeParser.Compound_statementContext,0)


        def select_statement(self):
            return self.getTypedRuleContext(QcodeParser.Select_statementContext,0)


        def while_statement(self):
            return self.getTypedRuleContext(QcodeParser.While_statementContext,0)


        def iterate_statement(self):
            return self.getTypedRuleContext(QcodeParser.Iterate_statementContext,0)


        def qif_statement(self):
            return self.getTypedRuleContext(QcodeParser.Qif_statementContext,0)


        def qwhile_statement(self):
            return self.getTypedRuleContext(QcodeParser.Qwhile_statementContext,0)


        def return_statement(self):
            return self.getTypedRuleContext(QcodeParser.Return_statementContext,0)


        def getRuleIndex(self):
            return QcodeParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatement" ):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)




    def statement(self):

        localctx = QcodeParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_statement)
        try:
            self.state = 427
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,24,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 417
                self.expression_statement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 418
                self.empty_statement()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 419
                self.declaration_variable_statement()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 420
                self.compound_statement()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 421
                self.select_statement()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 422
                self.while_statement()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 423
                self.iterate_statement()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 424
                self.qif_statement()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 425
                self.qwhile_statement()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 426
                self.return_statement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class While_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHILE(self):
            return self.getToken(QcodeParser.WHILE, 0)

        def LPAREN(self):
            return self.getToken(QcodeParser.LPAREN, 0)

        def single_expression(self):
            return self.getTypedRuleContext(QcodeParser.Single_expressionContext,0)


        def RPAREN(self):
            return self.getToken(QcodeParser.RPAREN, 0)

        def statement(self):
            return self.getTypedRuleContext(QcodeParser.StatementContext,0)


        def getRuleIndex(self):
            return QcodeParser.RULE_while_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhile_statement" ):
                listener.enterWhile_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhile_statement" ):
                listener.exitWhile_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhile_statement" ):
                return visitor.visitWhile_statement(self)
            else:
                return visitor.visitChildren(self)




    def while_statement(self):

        localctx = QcodeParser.While_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_while_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 429
            self.match(QcodeParser.WHILE)
            self.state = 430
            self.match(QcodeParser.LPAREN)
            self.state = 431
            self.single_expression(0)
            self.state = 432
            self.match(QcodeParser.RPAREN)
            self.state = 433
            self.statement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Return_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RETURN(self):
            return self.getToken(QcodeParser.RETURN, 0)

        def single_expression(self):
            return self.getTypedRuleContext(QcodeParser.Single_expressionContext,0)


        def SEMI(self):
            return self.getToken(QcodeParser.SEMI, 0)

        def getRuleIndex(self):
            return QcodeParser.RULE_return_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturn_statement" ):
                listener.enterReturn_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturn_statement" ):
                listener.exitReturn_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReturn_statement" ):
                return visitor.visitReturn_statement(self)
            else:
                return visitor.visitChildren(self)




    def return_statement(self):

        localctx = QcodeParser.Return_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_return_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 435
            self.match(QcodeParser.RETURN)
            self.state = 436
            self.single_expression(0)
            self.state = 437
            self.match(QcodeParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Qif_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def QIF(self):
            return self.getToken(QcodeParser.QIF, 0)

        def LPAREN(self):
            return self.getToken(QcodeParser.LPAREN, 0)

        def single_expression(self):
            return self.getTypedRuleContext(QcodeParser.Single_expressionContext,0)


        def RPAREN(self):
            return self.getToken(QcodeParser.RPAREN, 0)

        def LBRACE(self, i:int=None):
            if i is None:
                return self.getTokens(QcodeParser.LBRACE)
            else:
                return self.getToken(QcodeParser.LBRACE, i)

        def qif_true_branch(self):
            return self.getTypedRuleContext(QcodeParser.Qif_true_branchContext,0)


        def RBRACE(self, i:int=None):
            if i is None:
                return self.getTokens(QcodeParser.RBRACE)
            else:
                return self.getToken(QcodeParser.RBRACE, i)

        def QELSE(self):
            return self.getToken(QcodeParser.QELSE, 0)

        def qif_false_branch(self):
            return self.getTypedRuleContext(QcodeParser.Qif_false_branchContext,0)


        def getRuleIndex(self):
            return QcodeParser.RULE_qif_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQif_statement" ):
                listener.enterQif_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQif_statement" ):
                listener.exitQif_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQif_statement" ):
                return visitor.visitQif_statement(self)
            else:
                return visitor.visitChildren(self)




    def qif_statement(self):

        localctx = QcodeParser.Qif_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_qif_statement)
        try:
            self.state = 459
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,25,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 439
                self.match(QcodeParser.QIF)
                self.state = 440
                self.match(QcodeParser.LPAREN)
                self.state = 441
                self.single_expression(0)
                self.state = 442
                self.match(QcodeParser.RPAREN)
                self.state = 443
                self.match(QcodeParser.LBRACE)
                self.state = 444
                self.qif_true_branch()
                self.state = 445
                self.match(QcodeParser.RBRACE)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 447
                self.match(QcodeParser.QIF)
                self.state = 448
                self.match(QcodeParser.LPAREN)
                self.state = 449
                self.single_expression(0)
                self.state = 450
                self.match(QcodeParser.RPAREN)
                self.state = 451
                self.match(QcodeParser.LBRACE)
                self.state = 452
                self.qif_true_branch()
                self.state = 453
                self.match(QcodeParser.RBRACE)
                self.state = 454
                self.match(QcodeParser.QELSE)
                self.state = 455
                self.match(QcodeParser.LBRACE)
                self.state = 456
                self.qif_false_branch()
                self.state = 457
                self.match(QcodeParser.RBRACE)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Qif_true_branchContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement_list(self):
            return self.getTypedRuleContext(QcodeParser.Statement_listContext,0)


        def getRuleIndex(self):
            return QcodeParser.RULE_qif_true_branch

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQif_true_branch" ):
                listener.enterQif_true_branch(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQif_true_branch" ):
                listener.exitQif_true_branch(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQif_true_branch" ):
                return visitor.visitQif_true_branch(self)
            else:
                return visitor.visitChildren(self)




    def qif_true_branch(self):

        localctx = QcodeParser.Qif_true_branchContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_qif_true_branch)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 461
            self.statement_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Qif_false_branchContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement_list(self):
            return self.getTypedRuleContext(QcodeParser.Statement_listContext,0)


        def getRuleIndex(self):
            return QcodeParser.RULE_qif_false_branch

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQif_false_branch" ):
                listener.enterQif_false_branch(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQif_false_branch" ):
                listener.exitQif_false_branch(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQif_false_branch" ):
                return visitor.visitQif_false_branch(self)
            else:
                return visitor.visitChildren(self)




    def qif_false_branch(self):

        localctx = QcodeParser.Qif_false_branchContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_qif_false_branch)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 463
            self.statement_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Qwhile_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def QWHILE(self):
            return self.getToken(QcodeParser.QWHILE, 0)

        def LPAREN(self):
            return self.getToken(QcodeParser.LPAREN, 0)

        def single_expression(self):
            return self.getTypedRuleContext(QcodeParser.Single_expressionContext,0)


        def RPAREN(self):
            return self.getToken(QcodeParser.RPAREN, 0)

        def LBRACE(self):
            return self.getToken(QcodeParser.LBRACE, 0)

        def statement_list(self):
            return self.getTypedRuleContext(QcodeParser.Statement_listContext,0)


        def RBRACE(self):
            return self.getToken(QcodeParser.RBRACE, 0)

        def getRuleIndex(self):
            return QcodeParser.RULE_qwhile_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQwhile_statement" ):
                listener.enterQwhile_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQwhile_statement" ):
                listener.exitQwhile_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQwhile_statement" ):
                return visitor.visitQwhile_statement(self)
            else:
                return visitor.visitChildren(self)




    def qwhile_statement(self):

        localctx = QcodeParser.Qwhile_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_qwhile_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 465
            self.match(QcodeParser.QWHILE)
            self.state = 466
            self.match(QcodeParser.LPAREN)
            self.state = 467
            self.single_expression(0)
            self.state = 468
            self.match(QcodeParser.RPAREN)
            self.state = 469
            self.match(QcodeParser.LBRACE)
            self.state = 470
            self.statement_list()
            self.state = 471
            self.match(QcodeParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Expression_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def single_expression(self):
            return self.getTypedRuleContext(QcodeParser.Single_expressionContext,0)


        def SEMI(self):
            return self.getToken(QcodeParser.SEMI, 0)

        def getRuleIndex(self):
            return QcodeParser.RULE_expression_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression_statement" ):
                listener.enterExpression_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression_statement" ):
                listener.exitExpression_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpression_statement" ):
                return visitor.visitExpression_statement(self)
            else:
                return visitor.visitChildren(self)




    def expression_statement(self):

        localctx = QcodeParser.Expression_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_expression_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 473
            self.single_expression(0)
            self.state = 474
            self.match(QcodeParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Empty_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SEMI(self):
            return self.getToken(QcodeParser.SEMI, 0)

        def getRuleIndex(self):
            return QcodeParser.RULE_empty_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEmpty_statement" ):
                listener.enterEmpty_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEmpty_statement" ):
                listener.exitEmpty_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEmpty_statement" ):
                return visitor.visitEmpty_statement(self)
            else:
                return visitor.visitChildren(self)




    def empty_statement(self):

        localctx = QcodeParser.Empty_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_empty_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 476
            self.match(QcodeParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Declaration_variable_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def declaration_variable(self):
            return self.getTypedRuleContext(QcodeParser.Declaration_variableContext,0)


        def getRuleIndex(self):
            return QcodeParser.RULE_declaration_variable_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclaration_variable_statement" ):
                listener.enterDeclaration_variable_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclaration_variable_statement" ):
                listener.exitDeclaration_variable_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeclaration_variable_statement" ):
                return visitor.visitDeclaration_variable_statement(self)
            else:
                return visitor.visitChildren(self)




    def declaration_variable_statement(self):

        localctx = QcodeParser.Declaration_variable_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_declaration_variable_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 478
            self.declaration_variable()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Compound_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACE(self):
            return self.getToken(QcodeParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(QcodeParser.RBRACE, 0)

        def statement_list(self):
            return self.getTypedRuleContext(QcodeParser.Statement_listContext,0)


        def getRuleIndex(self):
            return QcodeParser.RULE_compound_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompound_statement" ):
                listener.enterCompound_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompound_statement" ):
                listener.exitCompound_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompound_statement" ):
                return visitor.visitCompound_statement(self)
            else:
                return visitor.visitChildren(self)




    def compound_statement(self):

        localctx = QcodeParser.Compound_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_compound_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 480
            self.match(QcodeParser.LBRACE)
            self.state = 482
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << QcodeParser.LET) | (1 << QcodeParser.INCLUDE) | (1 << QcodeParser.INT) | (1 << QcodeParser.BOOL) | (1 << QcodeParser.IF) | (1 << QcodeParser.ELSE) | (1 << QcodeParser.FOR) | (1 << QcodeParser.LIB) | (1 << QcodeParser.QRUNES) | (1 << QcodeParser.AVAR) | (1 << QcodeParser.DOUBLE) | (1 << QcodeParser.MAP) | (1 << QcodeParser.IN) | (1 << QcodeParser.VECTOR) | (1 << QcodeParser.PI) | (1 << QcodeParser.RETURN) | (1 << QcodeParser.LAMBDA) | (1 << QcodeParser.BREAK) | (1 << QcodeParser.CONTINUE) | (1 << QcodeParser.TRUE) | (1 << QcodeParser.FALSE) | (1 << QcodeParser.QUBIT) | (1 << QcodeParser.CBIT) | (1 << QcodeParser.CIRCUIT) | (1 << QcodeParser.VARIATIONALCIRCUIT) | (1 << QcodeParser.VQG_CNOT_VCGEN) | (1 << QcodeParser.VQG_RZ_VCGEN) | (1 << QcodeParser.VQG_RX_VCGEN) | (1 << QcodeParser.H_GATE) | (1 << QcodeParser.X_GATE) | (1 << QcodeParser.NOT_GATE) | (1 << QcodeParser.T_GATE) | (1 << QcodeParser.S_GATE) | (1 << QcodeParser.Y_GATE) | (1 << QcodeParser.Z_GATE) | (1 << QcodeParser.X1_GATE) | (1 << QcodeParser.Y1_GATE) | (1 << QcodeParser.Z1_GATE) | (1 << QcodeParser.U4_GATE) | (1 << QcodeParser.RX_GATE) | (1 << QcodeParser.RY_GATE) | (1 << QcodeParser.RZ_GATE) | (1 << QcodeParser.TOFFOLI_GATE) | (1 << QcodeParser.CNOT_GATE) | (1 << QcodeParser.CZ_GATE) | (1 << QcodeParser.CR_GATE) | (1 << QcodeParser.CU_GATE) | (1 << QcodeParser.ISWAP) | (1 << QcodeParser.APPLY_QGATE) | (1 << QcodeParser.MEASURE) | (1 << QcodeParser.MEASUREALL) | (1 << QcodeParser.QIF) | (1 << QcodeParser.QWHILE) | (1 << QcodeParser.QELSE) | (1 << QcodeParser.WHILE))) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (QcodeParser.BANG - 65)) | (1 << (QcodeParser.TILDE - 65)) | (1 << (QcodeParser.INC - 65)) | (1 << (QcodeParser.DEC - 65)) | (1 << (QcodeParser.SUB - 65)) | (1 << (QcodeParser.LBRACE - 65)) | (1 << (QcodeParser.SEMI - 65)) | (1 << (QcodeParser.LPAREN - 65)) | (1 << (QcodeParser.LBRACK - 65)) | (1 << (QcodeParser.Identifier - 65)) | (1 << (QcodeParser.Integer_Literal - 65)) | (1 << (QcodeParser.Double_Literal - 65)))) != 0):
                self.state = 481
                self.statement_list()


            self.state = 484
            self.match(QcodeParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Select_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.if_stmt = None # StatementContext
            self.else_stmt = None # StatementContext

        def IF(self):
            return self.getToken(QcodeParser.IF, 0)

        def LPAREN(self):
            return self.getToken(QcodeParser.LPAREN, 0)

        def single_expression(self):
            return self.getTypedRuleContext(QcodeParser.Single_expressionContext,0)


        def RPAREN(self):
            return self.getToken(QcodeParser.RPAREN, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QcodeParser.StatementContext)
            else:
                return self.getTypedRuleContext(QcodeParser.StatementContext,i)


        def ELSE(self):
            return self.getToken(QcodeParser.ELSE, 0)

        def getRuleIndex(self):
            return QcodeParser.RULE_select_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelect_statement" ):
                listener.enterSelect_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelect_statement" ):
                listener.exitSelect_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSelect_statement" ):
                return visitor.visitSelect_statement(self)
            else:
                return visitor.visitChildren(self)




    def select_statement(self):

        localctx = QcodeParser.Select_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_select_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 486
            self.match(QcodeParser.IF)
            self.state = 487
            self.match(QcodeParser.LPAREN)
            self.state = 488
            self.single_expression(0)
            self.state = 489
            self.match(QcodeParser.RPAREN)
            self.state = 490
            localctx.if_stmt = self.statement()
            self.state = 493
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,27,self._ctx)
            if la_ == 1:
                self.state = 491
                self.match(QcodeParser.ELSE)
                self.state = 492
                localctx.else_stmt = self.statement()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Iterate_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR(self):
            return self.getToken(QcodeParser.FOR, 0)

        def LPAREN(self):
            return self.getToken(QcodeParser.LPAREN, 0)

        def for_stmt(self):
            return self.getTypedRuleContext(QcodeParser.For_stmtContext,0)


        def RPAREN(self):
            return self.getToken(QcodeParser.RPAREN, 0)

        def statement(self):
            return self.getTypedRuleContext(QcodeParser.StatementContext,0)


        def inhanced_for_stmt(self):
            return self.getTypedRuleContext(QcodeParser.Inhanced_for_stmtContext,0)


        def getRuleIndex(self):
            return QcodeParser.RULE_iterate_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIterate_statement" ):
                listener.enterIterate_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIterate_statement" ):
                listener.exitIterate_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIterate_statement" ):
                return visitor.visitIterate_statement(self)
            else:
                return visitor.visitChildren(self)




    def iterate_statement(self):

        localctx = QcodeParser.Iterate_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_iterate_statement)
        try:
            self.state = 507
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,28,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 495
                self.match(QcodeParser.FOR)
                self.state = 496
                self.match(QcodeParser.LPAREN)
                self.state = 497
                self.for_stmt()
                self.state = 498
                self.match(QcodeParser.RPAREN)
                self.state = 499
                self.statement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 501
                self.match(QcodeParser.FOR)
                self.state = 502
                self.match(QcodeParser.LPAREN)
                self.state = 503
                self.inhanced_for_stmt()
                self.state = 504
                self.match(QcodeParser.RPAREN)
                self.state = 505
                self.statement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class For_stmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(QcodeParser.COLON)
            else:
                return self.getToken(QcodeParser.COLON, i)

        def for_start(self):
            return self.getTypedRuleContext(QcodeParser.For_startContext,0)


        def for_step(self):
            return self.getTypedRuleContext(QcodeParser.For_stepContext,0)


        def for_condition(self):
            return self.getTypedRuleContext(QcodeParser.For_conditionContext,0)


        def getRuleIndex(self):
            return QcodeParser.RULE_for_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFor_stmt" ):
                listener.enterFor_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFor_stmt" ):
                listener.exitFor_stmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFor_stmt" ):
                return visitor.visitFor_stmt(self)
            else:
                return visitor.visitChildren(self)




    def for_stmt(self):

        localctx = QcodeParser.For_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_for_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 510
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==QcodeParser.LET or _la==QcodeParser.Identifier:
                self.state = 509
                self.for_start()


            self.state = 512
            self.match(QcodeParser.COLON)
            self.state = 514
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << QcodeParser.LET) | (1 << QcodeParser.INCLUDE) | (1 << QcodeParser.INT) | (1 << QcodeParser.BOOL) | (1 << QcodeParser.IF) | (1 << QcodeParser.ELSE) | (1 << QcodeParser.FOR) | (1 << QcodeParser.LIB) | (1 << QcodeParser.QRUNES) | (1 << QcodeParser.AVAR) | (1 << QcodeParser.DOUBLE) | (1 << QcodeParser.IN) | (1 << QcodeParser.PI) | (1 << QcodeParser.RETURN) | (1 << QcodeParser.LAMBDA) | (1 << QcodeParser.BREAK) | (1 << QcodeParser.CONTINUE) | (1 << QcodeParser.TRUE) | (1 << QcodeParser.FALSE) | (1 << QcodeParser.QUBIT) | (1 << QcodeParser.CBIT) | (1 << QcodeParser.VQG_CNOT_VCGEN) | (1 << QcodeParser.VQG_RZ_VCGEN) | (1 << QcodeParser.VQG_RX_VCGEN) | (1 << QcodeParser.H_GATE) | (1 << QcodeParser.X_GATE) | (1 << QcodeParser.NOT_GATE) | (1 << QcodeParser.T_GATE) | (1 << QcodeParser.S_GATE) | (1 << QcodeParser.Y_GATE) | (1 << QcodeParser.Z_GATE) | (1 << QcodeParser.X1_GATE) | (1 << QcodeParser.Y1_GATE) | (1 << QcodeParser.Z1_GATE) | (1 << QcodeParser.U4_GATE) | (1 << QcodeParser.RX_GATE) | (1 << QcodeParser.RY_GATE) | (1 << QcodeParser.RZ_GATE) | (1 << QcodeParser.TOFFOLI_GATE) | (1 << QcodeParser.CNOT_GATE) | (1 << QcodeParser.CZ_GATE) | (1 << QcodeParser.CR_GATE) | (1 << QcodeParser.CU_GATE) | (1 << QcodeParser.ISWAP) | (1 << QcodeParser.APPLY_QGATE) | (1 << QcodeParser.MEASURE) | (1 << QcodeParser.MEASUREALL) | (1 << QcodeParser.QIF) | (1 << QcodeParser.QWHILE) | (1 << QcodeParser.QELSE))) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (QcodeParser.BANG - 65)) | (1 << (QcodeParser.TILDE - 65)) | (1 << (QcodeParser.INC - 65)) | (1 << (QcodeParser.DEC - 65)) | (1 << (QcodeParser.SUB - 65)) | (1 << (QcodeParser.LPAREN - 65)) | (1 << (QcodeParser.LBRACK - 65)) | (1 << (QcodeParser.Identifier - 65)) | (1 << (QcodeParser.Integer_Literal - 65)) | (1 << (QcodeParser.Double_Literal - 65)))) != 0):
                self.state = 513
                self.for_step()


            self.state = 516
            self.match(QcodeParser.COLON)
            self.state = 518
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << QcodeParser.LET) | (1 << QcodeParser.INCLUDE) | (1 << QcodeParser.INT) | (1 << QcodeParser.BOOL) | (1 << QcodeParser.IF) | (1 << QcodeParser.ELSE) | (1 << QcodeParser.FOR) | (1 << QcodeParser.LIB) | (1 << QcodeParser.QRUNES) | (1 << QcodeParser.AVAR) | (1 << QcodeParser.DOUBLE) | (1 << QcodeParser.IN) | (1 << QcodeParser.PI) | (1 << QcodeParser.RETURN) | (1 << QcodeParser.LAMBDA) | (1 << QcodeParser.BREAK) | (1 << QcodeParser.CONTINUE) | (1 << QcodeParser.TRUE) | (1 << QcodeParser.FALSE) | (1 << QcodeParser.QUBIT) | (1 << QcodeParser.CBIT) | (1 << QcodeParser.VQG_CNOT_VCGEN) | (1 << QcodeParser.VQG_RZ_VCGEN) | (1 << QcodeParser.VQG_RX_VCGEN) | (1 << QcodeParser.H_GATE) | (1 << QcodeParser.X_GATE) | (1 << QcodeParser.NOT_GATE) | (1 << QcodeParser.T_GATE) | (1 << QcodeParser.S_GATE) | (1 << QcodeParser.Y_GATE) | (1 << QcodeParser.Z_GATE) | (1 << QcodeParser.X1_GATE) | (1 << QcodeParser.Y1_GATE) | (1 << QcodeParser.Z1_GATE) | (1 << QcodeParser.U4_GATE) | (1 << QcodeParser.RX_GATE) | (1 << QcodeParser.RY_GATE) | (1 << QcodeParser.RZ_GATE) | (1 << QcodeParser.TOFFOLI_GATE) | (1 << QcodeParser.CNOT_GATE) | (1 << QcodeParser.CZ_GATE) | (1 << QcodeParser.CR_GATE) | (1 << QcodeParser.CU_GATE) | (1 << QcodeParser.ISWAP) | (1 << QcodeParser.APPLY_QGATE) | (1 << QcodeParser.MEASURE) | (1 << QcodeParser.MEASUREALL) | (1 << QcodeParser.QIF) | (1 << QcodeParser.QWHILE) | (1 << QcodeParser.QELSE))) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (QcodeParser.BANG - 65)) | (1 << (QcodeParser.TILDE - 65)) | (1 << (QcodeParser.INC - 65)) | (1 << (QcodeParser.DEC - 65)) | (1 << (QcodeParser.SUB - 65)) | (1 << (QcodeParser.LPAREN - 65)) | (1 << (QcodeParser.LBRACK - 65)) | (1 << (QcodeParser.Identifier - 65)) | (1 << (QcodeParser.Integer_Literal - 65)) | (1 << (QcodeParser.Double_Literal - 65)))) != 0):
                self.state = 517
                self.for_condition()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class For_stepContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def single_expression(self):
            return self.getTypedRuleContext(QcodeParser.Single_expressionContext,0)


        def getRuleIndex(self):
            return QcodeParser.RULE_for_step

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFor_step" ):
                listener.enterFor_step(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFor_step" ):
                listener.exitFor_step(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFor_step" ):
                return visitor.visitFor_step(self)
            else:
                return visitor.visitChildren(self)




    def for_step(self):

        localctx = QcodeParser.For_stepContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_for_step)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 520
            self.single_expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class For_conditionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def single_expression(self):
            return self.getTypedRuleContext(QcodeParser.Single_expressionContext,0)


        def getRuleIndex(self):
            return QcodeParser.RULE_for_condition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFor_condition" ):
                listener.enterFor_condition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFor_condition" ):
                listener.exitFor_condition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFor_condition" ):
                return visitor.visitFor_condition(self)
            else:
                return visitor.visitChildren(self)




    def for_condition(self):

        localctx = QcodeParser.For_conditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_for_condition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 522
            self.single_expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class For_startContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(QcodeParser.Identifier, 0)

        def LET(self):
            return self.getToken(QcodeParser.LET, 0)

        def ASSIGN(self):
            return self.getToken(QcodeParser.ASSIGN, 0)

        def single_expression(self):
            return self.getTypedRuleContext(QcodeParser.Single_expressionContext,0)


        def getRuleIndex(self):
            return QcodeParser.RULE_for_start

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFor_start" ):
                listener.enterFor_start(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFor_start" ):
                listener.exitFor_start(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFor_start" ):
                return visitor.visitFor_start(self)
            else:
                return visitor.visitChildren(self)




    def for_start(self):

        localctx = QcodeParser.For_startContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_for_start)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 525
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==QcodeParser.LET:
                self.state = 524
                self.match(QcodeParser.LET)


            self.state = 527
            self.match(QcodeParser.Identifier)
            self.state = 530
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==QcodeParser.ASSIGN:
                self.state = 528
                self.match(QcodeParser.ASSIGN)
                self.state = 529
                self.single_expression(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Inhanced_for_stmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def construct_primary_type(self):
            return self.getTypedRuleContext(QcodeParser.Construct_primary_typeContext,0)


        def Identifier(self):
            return self.getToken(QcodeParser.Identifier, 0)

        def IN(self):
            return self.getToken(QcodeParser.IN, 0)

        def single_expression(self):
            return self.getTypedRuleContext(QcodeParser.Single_expressionContext,0)


        def getRuleIndex(self):
            return QcodeParser.RULE_inhanced_for_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInhanced_for_stmt" ):
                listener.enterInhanced_for_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInhanced_for_stmt" ):
                listener.exitInhanced_for_stmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInhanced_for_stmt" ):
                return visitor.visitInhanced_for_stmt(self)
            else:
                return visitor.visitChildren(self)




    def inhanced_for_stmt(self):

        localctx = QcodeParser.Inhanced_for_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_inhanced_for_stmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 532
            self.construct_primary_type()
            self.state = 533
            self.match(QcodeParser.Identifier)
            self.state = 534
            self.match(QcodeParser.IN)
            self.state = 535
            self.single_expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Statement_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(QcodeParser.StatementContext)
            else:
                return self.getTypedRuleContext(QcodeParser.StatementContext,i)


        def getRuleIndex(self):
            return QcodeParser.RULE_statement_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement_list" ):
                listener.enterStatement_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement_list" ):
                listener.exitStatement_list(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatement_list" ):
                return visitor.visitStatement_list(self)
            else:
                return visitor.visitChildren(self)




    def statement_list(self):

        localctx = QcodeParser.Statement_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_statement_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 538 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 537
                self.statement()
                self.state = 540 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << QcodeParser.LET) | (1 << QcodeParser.INCLUDE) | (1 << QcodeParser.INT) | (1 << QcodeParser.BOOL) | (1 << QcodeParser.IF) | (1 << QcodeParser.ELSE) | (1 << QcodeParser.FOR) | (1 << QcodeParser.LIB) | (1 << QcodeParser.QRUNES) | (1 << QcodeParser.AVAR) | (1 << QcodeParser.DOUBLE) | (1 << QcodeParser.MAP) | (1 << QcodeParser.IN) | (1 << QcodeParser.VECTOR) | (1 << QcodeParser.PI) | (1 << QcodeParser.RETURN) | (1 << QcodeParser.LAMBDA) | (1 << QcodeParser.BREAK) | (1 << QcodeParser.CONTINUE) | (1 << QcodeParser.TRUE) | (1 << QcodeParser.FALSE) | (1 << QcodeParser.QUBIT) | (1 << QcodeParser.CBIT) | (1 << QcodeParser.CIRCUIT) | (1 << QcodeParser.VARIATIONALCIRCUIT) | (1 << QcodeParser.VQG_CNOT_VCGEN) | (1 << QcodeParser.VQG_RZ_VCGEN) | (1 << QcodeParser.VQG_RX_VCGEN) | (1 << QcodeParser.H_GATE) | (1 << QcodeParser.X_GATE) | (1 << QcodeParser.NOT_GATE) | (1 << QcodeParser.T_GATE) | (1 << QcodeParser.S_GATE) | (1 << QcodeParser.Y_GATE) | (1 << QcodeParser.Z_GATE) | (1 << QcodeParser.X1_GATE) | (1 << QcodeParser.Y1_GATE) | (1 << QcodeParser.Z1_GATE) | (1 << QcodeParser.U4_GATE) | (1 << QcodeParser.RX_GATE) | (1 << QcodeParser.RY_GATE) | (1 << QcodeParser.RZ_GATE) | (1 << QcodeParser.TOFFOLI_GATE) | (1 << QcodeParser.CNOT_GATE) | (1 << QcodeParser.CZ_GATE) | (1 << QcodeParser.CR_GATE) | (1 << QcodeParser.CU_GATE) | (1 << QcodeParser.ISWAP) | (1 << QcodeParser.APPLY_QGATE) | (1 << QcodeParser.MEASURE) | (1 << QcodeParser.MEASUREALL) | (1 << QcodeParser.QIF) | (1 << QcodeParser.QWHILE) | (1 << QcodeParser.QELSE) | (1 << QcodeParser.WHILE))) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (QcodeParser.BANG - 65)) | (1 << (QcodeParser.TILDE - 65)) | (1 << (QcodeParser.INC - 65)) | (1 << (QcodeParser.DEC - 65)) | (1 << (QcodeParser.SUB - 65)) | (1 << (QcodeParser.LBRACE - 65)) | (1 << (QcodeParser.SEMI - 65)) | (1 << (QcodeParser.LPAREN - 65)) | (1 << (QcodeParser.LBRACK - 65)) | (1 << (QcodeParser.Identifier - 65)) | (1 << (QcodeParser.Integer_Literal - 65)) | (1 << (QcodeParser.Double_Literal - 65)))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Function_definitionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def declarate_function(self):
            return self.getTypedRuleContext(QcodeParser.Declarate_functionContext,0)


        def function_body(self):
            return self.getTypedRuleContext(QcodeParser.Function_bodyContext,0)


        def getRuleIndex(self):
            return QcodeParser.RULE_function_definition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_definition" ):
                listener.enterFunction_definition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_definition" ):
                listener.exitFunction_definition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunction_definition" ):
                return visitor.visitFunction_definition(self)
            else:
                return visitor.visitChildren(self)




    def function_definition(self):

        localctx = QcodeParser.Function_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_function_definition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 542
            self.declarate_function()
            self.state = 543
            self.function_body()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Function_bodyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def compound_statement(self):
            return self.getTypedRuleContext(QcodeParser.Compound_statementContext,0)


        def getRuleIndex(self):
            return QcodeParser.RULE_function_body

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_body" ):
                listener.enterFunction_body(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_body" ):
                listener.exitFunction_body(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunction_body" ):
                return visitor.visitFunction_body(self)
            else:
                return visitor.visitChildren(self)




    def function_body(self):

        localctx = QcodeParser.Function_bodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_function_body)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 545
            self.compound_statement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Key_wordsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LET(self):
            return self.getToken(QcodeParser.LET, 0)

        def INCLUDE(self):
            return self.getToken(QcodeParser.INCLUDE, 0)

        def INT(self):
            return self.getToken(QcodeParser.INT, 0)

        def BOOL(self):
            return self.getToken(QcodeParser.BOOL, 0)

        def IF(self):
            return self.getToken(QcodeParser.IF, 0)

        def ELSE(self):
            return self.getToken(QcodeParser.ELSE, 0)

        def FOR(self):
            return self.getToken(QcodeParser.FOR, 0)

        def IN(self):
            return self.getToken(QcodeParser.IN, 0)

        def LIB(self):
            return self.getToken(QcodeParser.LIB, 0)

        def INC(self):
            return self.getToken(QcodeParser.INC, 0)

        def QRUNES(self):
            return self.getToken(QcodeParser.QRUNES, 0)

        def AVAR(self):
            return self.getToken(QcodeParser.AVAR, 0)

        def DOUBLE(self):
            return self.getToken(QcodeParser.DOUBLE, 0)

        def QUBIT(self):
            return self.getToken(QcodeParser.QUBIT, 0)

        def CBIT(self):
            return self.getToken(QcodeParser.CBIT, 0)

        def H_GATE(self):
            return self.getToken(QcodeParser.H_GATE, 0)

        def X_GATE(self):
            return self.getToken(QcodeParser.X_GATE, 0)

        def NOT_GATE(self):
            return self.getToken(QcodeParser.NOT_GATE, 0)

        def T_GATE(self):
            return self.getToken(QcodeParser.T_GATE, 0)

        def S_GATE(self):
            return self.getToken(QcodeParser.S_GATE, 0)

        def Y_GATE(self):
            return self.getToken(QcodeParser.Y_GATE, 0)

        def Z_GATE(self):
            return self.getToken(QcodeParser.Z_GATE, 0)

        def X1_GATE(self):
            return self.getToken(QcodeParser.X1_GATE, 0)

        def Y1_GATE(self):
            return self.getToken(QcodeParser.Y1_GATE, 0)

        def Z1_GATE(self):
            return self.getToken(QcodeParser.Z1_GATE, 0)

        def U4_GATE(self):
            return self.getToken(QcodeParser.U4_GATE, 0)

        def RX_GATE(self):
            return self.getToken(QcodeParser.RX_GATE, 0)

        def RY_GATE(self):
            return self.getToken(QcodeParser.RY_GATE, 0)

        def RZ_GATE(self):
            return self.getToken(QcodeParser.RZ_GATE, 0)

        def CNOT_GATE(self):
            return self.getToken(QcodeParser.CNOT_GATE, 0)

        def CZ_GATE(self):
            return self.getToken(QcodeParser.CZ_GATE, 0)

        def CR_GATE(self):
            return self.getToken(QcodeParser.CR_GATE, 0)

        def CU_GATE(self):
            return self.getToken(QcodeParser.CU_GATE, 0)

        def TOFFOLI_GATE(self):
            return self.getToken(QcodeParser.TOFFOLI_GATE, 0)

        def ISWAP(self):
            return self.getToken(QcodeParser.ISWAP, 0)

        def MEASURE(self):
            return self.getToken(QcodeParser.MEASURE, 0)

        def MEASUREALL(self):
            return self.getToken(QcodeParser.MEASUREALL, 0)

        def QIF(self):
            return self.getToken(QcodeParser.QIF, 0)

        def QWHILE(self):
            return self.getToken(QcodeParser.QWHILE, 0)

        def QELSE(self):
            return self.getToken(QcodeParser.QELSE, 0)

        def VQG_RZ_VCGEN(self):
            return self.getToken(QcodeParser.VQG_RZ_VCGEN, 0)

        def VQG_CNOT_VCGEN(self):
            return self.getToken(QcodeParser.VQG_CNOT_VCGEN, 0)

        def VQG_RX_VCGEN(self):
            return self.getToken(QcodeParser.VQG_RX_VCGEN, 0)

        def APPLY_QGATE(self):
            return self.getToken(QcodeParser.APPLY_QGATE, 0)

        def RETURN(self):
            return self.getToken(QcodeParser.RETURN, 0)

        def LAMBDA(self):
            return self.getToken(QcodeParser.LAMBDA, 0)

        def BREAK(self):
            return self.getToken(QcodeParser.BREAK, 0)

        def CONTINUE(self):
            return self.getToken(QcodeParser.CONTINUE, 0)

        def TRUE(self):
            return self.getToken(QcodeParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(QcodeParser.FALSE, 0)

        def getRuleIndex(self):
            return QcodeParser.RULE_key_words

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKey_words" ):
                listener.enterKey_words(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKey_words" ):
                listener.exitKey_words(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKey_words" ):
                return visitor.visitKey_words(self)
            else:
                return visitor.visitChildren(self)




    def key_words(self):

        localctx = QcodeParser.Key_wordsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_key_words)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 547
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << QcodeParser.LET) | (1 << QcodeParser.INCLUDE) | (1 << QcodeParser.INT) | (1 << QcodeParser.BOOL) | (1 << QcodeParser.IF) | (1 << QcodeParser.ELSE) | (1 << QcodeParser.FOR) | (1 << QcodeParser.LIB) | (1 << QcodeParser.QRUNES) | (1 << QcodeParser.AVAR) | (1 << QcodeParser.DOUBLE) | (1 << QcodeParser.IN) | (1 << QcodeParser.RETURN) | (1 << QcodeParser.LAMBDA) | (1 << QcodeParser.BREAK) | (1 << QcodeParser.CONTINUE) | (1 << QcodeParser.TRUE) | (1 << QcodeParser.FALSE) | (1 << QcodeParser.QUBIT) | (1 << QcodeParser.CBIT) | (1 << QcodeParser.VQG_CNOT_VCGEN) | (1 << QcodeParser.VQG_RZ_VCGEN) | (1 << QcodeParser.VQG_RX_VCGEN) | (1 << QcodeParser.H_GATE) | (1 << QcodeParser.X_GATE) | (1 << QcodeParser.NOT_GATE) | (1 << QcodeParser.T_GATE) | (1 << QcodeParser.S_GATE) | (1 << QcodeParser.Y_GATE) | (1 << QcodeParser.Z_GATE) | (1 << QcodeParser.X1_GATE) | (1 << QcodeParser.Y1_GATE) | (1 << QcodeParser.Z1_GATE) | (1 << QcodeParser.U4_GATE) | (1 << QcodeParser.RX_GATE) | (1 << QcodeParser.RY_GATE) | (1 << QcodeParser.RZ_GATE) | (1 << QcodeParser.TOFFOLI_GATE) | (1 << QcodeParser.CNOT_GATE) | (1 << QcodeParser.CZ_GATE) | (1 << QcodeParser.CR_GATE) | (1 << QcodeParser.CU_GATE) | (1 << QcodeParser.ISWAP) | (1 << QcodeParser.APPLY_QGATE) | (1 << QcodeParser.MEASURE) | (1 << QcodeParser.MEASUREALL) | (1 << QcodeParser.QIF) | (1 << QcodeParser.QWHILE) | (1 << QcodeParser.QELSE))) != 0) or _la==QcodeParser.INC):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConstantContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Integer_Literal(self):
            return self.getToken(QcodeParser.Integer_Literal, 0)

        def Double_Literal(self):
            return self.getToken(QcodeParser.Double_Literal, 0)

        def getRuleIndex(self):
            return QcodeParser.RULE_constant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstant" ):
                listener.enterConstant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstant" ):
                listener.exitConstant(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstant" ):
                return visitor.visitConstant(self)
            else:
                return visitor.visitChildren(self)




    def constant(self):

        localctx = QcodeParser.ConstantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_constant)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 549
            _la = self._input.LA(1)
            if not(_la==QcodeParser.Integer_Literal or _la==QcodeParser.Double_Literal):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[17] = self.call_back_primary_type_list_sempred
        self._predicates[22] = self.init_declaratorlist_sempred
        self._predicates[24] = self.variableInitializer_sempred
        self._predicates[30] = self.parameter_decl_list_sempred
        self._predicates[31] = self.expression_list_sempred
        self._predicates[34] = self.single_expression_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def call_back_primary_type_list_sempred(self, localctx:Call_back_primary_type_listContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 1)
         

    def init_declaratorlist_sempred(self, localctx:Init_declaratorlistContext, predIndex:int):
            if predIndex == 1:
                return self.precpred(self._ctx, 1)
         

    def variableInitializer_sempred(self, localctx:VariableInitializerContext, predIndex:int):
            if predIndex == 2:
                return self.precpred(self._ctx, 1)
         

    def parameter_decl_list_sempred(self, localctx:Parameter_decl_listContext, predIndex:int):
            if predIndex == 3:
                return self.precpred(self._ctx, 1)
         

    def expression_list_sempred(self, localctx:Expression_listContext, predIndex:int):
            if predIndex == 4:
                return self.precpred(self._ctx, 1)
         

    def single_expression_sempred(self, localctx:Single_expressionContext, predIndex:int):
            if predIndex == 5:
                return self.precpred(self._ctx, 18)
         

            if predIndex == 6:
                return self.precpred(self._ctx, 13)
         

            if predIndex == 7:
                return self.precpred(self._ctx, 12)
         

            if predIndex == 8:
                return self.precpred(self._ctx, 11)
         

            if predIndex == 9:
                return self.precpred(self._ctx, 10)
         

            if predIndex == 10:
                return self.precpred(self._ctx, 9)
         

            if predIndex == 11:
                return self.precpred(self._ctx, 8)
         

            if predIndex == 12:
                return self.precpred(self._ctx, 7)
         

            if predIndex == 13:
                return self.precpred(self._ctx, 6)
         

            if predIndex == 14:
                return self.precpred(self._ctx, 19)
         

            if predIndex == 15:
                return self.precpred(self._ctx, 17)
         

            if predIndex == 16:
                return self.precpred(self._ctx, 16)
         

            if predIndex == 17:
                return self.precpred(self._ctx, 15)
         




